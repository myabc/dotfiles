desc 'Clone a copy of the DataMapper repository and dependencies'
task 'dm:clone' do
  if File.directory?("dm") then
    puts("./dm already exists!")
    exit
  end
  require("fileutils")
  mkdir("dm")
  cd("dm")
  ["do", "dm-core", "dm-more"].each do |r|
    sh("git clone git://github.com/sam/#{r}.git")
  end
end

desc 'Update your local DataMapper.  Run from inside the top-level dm directory.'
task 'dm:update' do
  repos = ["do", "dm-core", "dm-more"]
  repos.each do |r|
    unless File.directory?(r) then
      puts("#{r} missing ... did you use dm:create to set this up?")
      exit
    end
  end
  repos.each do |r|
    puts("Updating #{r}")
    cd(r)
    sh("git fetch")
    sh("git rebase origin/master")
    cd("..")
  end
end

desc 'Uninstall all RubyGems related to DataMapper'
task 'dm:gems:wipe' do
  sudo = RUBY_PLATFORM =~ /win32|cygwin/ ? ("") : ("sudo")
  ["dm-core", "merb_datamapper", "do_sqlite3", "do_mysql", "do_postgres", "data_objects"].each do |gem|
    sh("#{sudo} gem uninstall #{gem} --all --ignore-dependencies --executables; true")
  end
end

desc 'Pull fresh copies of DataMapper and refresh all the gems'
task 'dm:gems:refresh' => [ 'dm:gems:wipe', 'dm:update', 'dm:install' ] do

end

desc 'Install dm-core, dm-more and do'
task 'dm:install' => [ 'dm:install:do', 'dm:install:core', 'dm:install:more' ] do

end

desc 'Install dm-core'
task 'dm:install:core' do
  cd("dm-core")
  sh("rake install; true")
  cd("..")
end

desc 'Install dm-more'
task 'dm:install:more' => [ 'dm:install:more:timestamps', 'dm:install:more:validations', 'dm:install:more:merb_datamapper' ] do

end

desc 'Install dm-timestamps'
task 'dm:install:more:timestamps' do
  cd("dm-more/dm-timestamps")
  sh("rake install; true")
  cd("../..")
end

desc 'Install dm-validations'
task 'dm:install:more:validations' do
  cd("dm-more/dm-validations")
  sh("rake install; true")
  cd("../..")
end

desc 'Install merb_datamapper'
task 'dm:install:more:merb_datamapper' do
  cd("dm-more/merb_datamapper")
  sh("rake install; true")
  cd("../..")
end

desc 'Install do drivers'
task 'dm:install:do' => [ 'dm:install:do:data_objects', 'dm:install:do:postgres', 'dm:install:do:mysql', 'dm:install:do:sqlite3' ] do

end

desc 'Install data_objects'
task 'dm:install:do:data_objects' do
  cd("do/data_objects")
  sh("rake install; true")
  cd("../..")
end

desc 'Install do_postgres'
task 'dm:install:do:postgres' do
  cd("do/do_postgres")
  sh("rake install; true")
  cd("../..")
end

desc 'Install do_mysql'
task 'dm:install:do:mysql' do
  cd("do/do_mysql")
  sh("rake install; true")
  cd("../..")
end

desc 'Install do_sqlite3'
task 'dm:install:do:sqlite3' do
  cd("do/do_sqlite3")
  sh("rake install; true")
  cd("../..")
end

desc 'Remove and reinstall DataMapper sake recipes'
task 'dm:sake:refresh' do
  tasks = ["dm:clone", "dm:gems:refresh", "dm:gems:wipe", "dm:install", "dm:install:core", "dm:install:do", "dm:install:do:data_objects", "dm:install:do:mysql", "dm:install:do:postgres", "dm:install:do:sqlite3", "dm:install:more", "dm:install:more:timestamps", "dm:install:more:validations", "dm:install:more:merb_datamapper", "dm:update", "dm:sake:refresh", "strip"]
  sh("sake -u #{(tasks * " ")}")
  sh("sake -i http://datamapper.org/dm-dev.sake")
end

desc 'Strip trailing whitespace from source files'
task 'strip' do
  require("pathname")
  require("zlib")
  files = ["capfile", "CHANGELOG", "MIT-LICENSE", "README", "README_FOR_APP", "RUNNING_UNIT_TESTS", "Rakefile", "TODO", "USAGE", ".autotest", ".gitignore"].freeze
  extensions = ["builder", "cgi", "conf", "css", "deploy", "erb", "example", "fcgi", "haml", "htc", "htm", "html", "js", "key", "opts", "php", "rake", "ratom", "rb", "rcsv", "rdf", "rhtml", "rjs", "rpdf", "rxml", "sake", "sass", "sh", "sql", "txt", "vcf", "xml", "yml"].freeze
  Pathname.getwd.find do |path|
    if ((path.directory? and ((not path.readable?) or (not path.writable?))) or [".git", ".svn"].include?(path.basename.to_s)) then
      Find.prune
    end
    unless (path.file? and (path.size? and (files.include?(path.basename.to_s) or extensions.include?(path.extname[(1..-1)])))) then
      next
    end
    document = (path.open("r") do |f|
      f.collect { |line| (line.gsub(/\G\s/, " ").rstrip + "\n") }.join.rstrip
    end + "\n")
    next if (Zlib.crc32(document) == Zlib.crc32(path.read))
    puts("Stripping whitepsace from #{path}")
    path.open("w") { |f| f.write(document) }
  end
end
