/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of InternetConfig.xs. Do not edit this file, edit InternetConfig.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "InternetConfig.xs"
/* $Header: /cvsroot/macperl/perl/macos/ext/Mac/InternetConfig/InternetConfig.xs,v 1.6 2006/06/22 02:58:18 pudge Exp $
 *
 *    Copyright (c) 1995 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: InternetConfig.xs,v $
 * Revision 1.6  2006/06/22 02:58:18  pudge
 * various minor fixes
 *
 * Revision 1.5  2003/10/28 05:53:30  pudge
 * Add Carbon compat. notes
 *
 * Revision 1.4  2003/04/06 22:19:02  pudge
 * Port to Mac OS X/Mac::Carbon
 *
 * Revision 1.3  2002/01/23 05:44:42  pudge
 * Update whitespace etc., from Thomas
 *
 * Revision 1.2  2000/09/09 22:18:27  neeri
 * Dynamic libraries compile under 5.6
 *
 * Revision 1.1  2000/08/14 03:39:31  neeri
 * Checked into Sourceforge
 *
 * Revision 1.3  1998/04/07 01:02:55  neeri
 * MacPerl 5.2.0r4b1
 *
 * Revision 1.2  1997/11/18 00:52:27  neeri
 * MacPerl 5.1.5
 *
 * Revision 1.1  1997/04/07 20:49:49  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#undef pad

#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#define file_type fileType
#define file_creator fileCreator
#define post_creator postCreator
#define creator_app_name creatorAppName
#define post_app_name postAppName
#define MIME_type MIMEType
#define entry_name entryName
#else
#include <InternetConfig.h>
#include <GUSIFileSpec.h>
#include <Components.h>
#endif

static SV * MakeHndSV(Handle hdl)
{
	SV * res;
	char state;
	
	state = HGetState(hdl);
	HLock(hdl);
	res = GetHandleSize(hdl) ? newSVpv(*hdl, GetHandleSize(hdl)) : newSVpv("", 0);
	HSetState(hdl, state);
	
	return res;
}

#define PLstrcmp(s1, s2) memcmp((void *)s1, (void *)s2, s1[0]+1)
#define PLstrcpy(s1, s2) memcpy((void *)s1, (void *)s2, s1[0]+1)

static Boolean EqualMapEntries(ICMapEntry * e1, ICMapEntry *e2)
{
	return e1->file_type 	== e2->file_type
		&& e1->file_creator == e2->file_creator
		&& e1->post_creator == e2->post_creator
		&& !PLstrcmp(e1->extension, e2->extension)
		&& !PLstrcmp(e1->creator_app_name, e2->creator_app_name)
		&& !PLstrcmp(e1->post_app_name, e2->post_app_name)
		&& !PLstrcmp(e1->MIME_type, e2->MIME_type)
		&& !PLstrcmp(e1->entry_name, e2->entry_name);
}

#line 99 "InternetConfig.c"
XS(XS_Mac__InternetConfig_ICMapEntry)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	ICMapEntry STRUCT;

#line 91 "InternetConfig.xs"
	 STRUCT;

	if (sv_isa( ST(0), "ICMapEntry"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(ICMapEntry));
	else
	    croak(" STRUCT is not of type ICMapEntry");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* version */
#line 112 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.version));
		break;
	    case 1:	  /* file_type */
#line 113 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT.file_type));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    case 2:	  /* file_creator */
#line 114 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT.file_creator));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    case 3:	  /* post_creator */
#line 115 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT.post_creator));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    case 4:	  /* flags */
#line 116 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.flags));
		break;
	    case 5:	  /* extension */
#line 117 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.extension)) + 1, (STRUCT.extension)[0]);
		break;
	    case 6:	  /* creator_app_name */
#line 118 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.creator_app_name)) + 1, (STRUCT.creator_app_name)[0]);
		break;
	    case 7:	  /* post_app_name */
#line 119 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.post_app_name)) + 1, (STRUCT.post_app_name)[0]);
		break;
	    case 8:	  /* MIME_type */
#line 120 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.MIME_type)) + 1, (STRUCT.MIME_type)[0]);
		break;
	    case 9:	  /* entry_name */
#line 121 "InternetConfig.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.entry_name)) + 1, (STRUCT.entry_name)[0]);
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* version */
#line 112 "InternetConfig.xs"
	 STRUCT.version = (short)SvIV( ST(1));
		break;
	    case 1:	  /* file_type */
#line 113 "InternetConfig.xs"
	 STRUCT.file_type;

	memcpy(& STRUCT.file_type, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT.file_type = ntohl( STRUCT.file_type);
		break;
	    case 2:	  /* file_creator */
#line 114 "InternetConfig.xs"
	 STRUCT.file_creator;

	memcpy(& STRUCT.file_creator, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT.file_creator = ntohl( STRUCT.file_creator);
		break;
	    case 3:	  /* post_creator */
#line 115 "InternetConfig.xs"
	 STRUCT.post_creator;

	memcpy(& STRUCT.post_creator, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT.post_creator = ntohl( STRUCT.post_creator);
		break;
	    case 4:	  /* flags */
#line 116 "InternetConfig.xs"
	 STRUCT.flags = (long)SvIV( ST(1));
		break;
	    case 5:	  /* extension */
#line 117 "InternetConfig.xs"
	 STRUCT.extension;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.extension);
		break;
	    case 6:	  /* creator_app_name */
#line 118 "InternetConfig.xs"
	 STRUCT.creator_app_name;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.creator_app_name);
		break;
	    case 7:	  /* post_app_name */
#line 119 "InternetConfig.xs"
	 STRUCT.post_app_name;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.post_app_name);
		break;
	    case 8:	  /* MIME_type */
#line 120 "InternetConfig.xs"
	 STRUCT.MIME_type;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.MIME_type);
		break;
	    case 9:	  /* entry_name */
#line 121 "InternetConfig.xs"
	 STRUCT.entry_name;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.entry_name);
		break;
	    }
#line 91 "InternetConfig.xs"
	sv_setref_pvn( ST(0), "ICMapEntry", (void*)&( STRUCT), sizeof(ICMapEntry));
	}
    }
    XSRETURN(1);
}

XS(XS_ICMapEntry_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_ICMapEntry_new)
{
    dXSARGS;
    if (items != 9)
	Perl_croak(aTHX_ "Usage: ICMapEntry::new(file_type, file_creator, post_creator, flags, extension, creator_app_name, post_app_name, MIME_type, entry_name)");
    {
	OSType	file_type;
	OSType	file_creator;
	OSType	post_creator;
	long	flags = (long)SvIV(ST(3));
	Str255	extension;
	Str255	creator_app_name;
	Str255	post_app_name;
	Str255	MIME_type;
	Str255	entry_name;
	ICMapEntry	RETVAL;

	memcpy(&file_type, SvPV_nolen(ST(0)), sizeof(OSType));
	file_type = ntohl(file_type);

	memcpy(&file_creator, SvPV_nolen(ST(1)), sizeof(OSType));
	file_creator = ntohl(file_creator);

	memcpy(&post_creator, SvPV_nolen(ST(2)), sizeof(OSType));
	post_creator = ntohl(post_creator);

	MacPerl_CopyC2P(SvPV_nolen(ST(4)), extension);

	MacPerl_CopyC2P(SvPV_nolen(ST(5)), creator_app_name);

	MacPerl_CopyC2P(SvPV_nolen(ST(6)), post_app_name);

	MacPerl_CopyC2P(SvPV_nolen(ST(7)), MIME_type);

	MacPerl_CopyC2P(SvPV_nolen(ST(8)), entry_name);
#line 137 "InternetConfig.xs"
	RETVAL.version 	 	= 0;
	RETVAL.file_type 	= file_type;
	RETVAL.file_creator = file_creator;
	RETVAL.post_creator = post_creator;
	RETVAL.flags		= flags;
	PLstrcpy(RETVAL.extension, extension);
	PLstrcpy(RETVAL.creator_app_name, creator_app_name);
	PLstrcpy(RETVAL.post_app_name, post_app_name);
	PLstrcpy(RETVAL.MIME_type, MIME_type);
	PLstrcpy(RETVAL.entry_name, entry_name);
#line 302 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "ICMapEntry", (void*)&RETVAL, sizeof(ICMapEntry));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICStart); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICStart)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICStart(creator='McPL')");
    {
	OSType	creator;
	ICInstance	RETVAL;

	if (items < 1)
	    creator = 'McPL';
	else {
	    memcpy(&creator, SvPV_nolen(ST(0)), sizeof(OSType));
	    creator = ntohl(creator);
	}
#line 171 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICStart(&RETVAL, creator)) {
		XSRETURN_UNDEF;
	}
#line 329 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ICInstance", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICStop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICStop)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICStop(inst)");
    {
	ICInstance	inst;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	RETVAL = ICStop(inst);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGeneralFindConfigFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGeneralFindConfigFile)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGeneralFindConfigFile(inst, search_prefs=1, can_create=0, ...)");
    {
	ICInstance	inst;
	Boolean	search_prefs;
	Boolean	can_create;
#line 217 "InternetConfig.xs"
	int			i;
	short		count;
	FSSpec		spec;
	ICDirSpec	spex[8];
#line 375 "InternetConfig.c"
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (items < 2)
	    search_prefs = 1;
	else {
	    search_prefs = (bool)SvTRUE(ST(1));
	}

	if (items < 3)
	    can_create = 0;
	else {
	    can_create = (bool)SvTRUE(ST(2));
	}
#line 222 "InternetConfig.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::InternetConfig::ICGeneralFindConfigFile unsupported in Carbon");
#else
	count = 0;
	for (i=3; i<items; ++i)
		if (!GUSIPath2FSp((char *) SvPV_nolen(ST(i)), &spec) && !GUSIFSpDown(&spec, "\p")) {
			spex[count].vRefNum = spec.vRefNum;
			spex[count].dirID	= spec.parID;
			++count;
		}
	RETVAL = ICGeneralFindConfigFile(inst, search_prefs, can_create, count, (ICDirSpecArrayPtr) spex);
#endif
#line 410 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAA 1

XS(XS_Mac__InternetConfig_ICChooseConfig); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICChooseConfig)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICChooseConfig(inst)");
    {
	ICInstance	inst;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 255 "InternetConfig.xs"
	croak("Usage: Mac::InternetConfig::ICChooseConfig unsupported in Carbon");
#line 438 "InternetConfig.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAB 1

XS(XS_Mac__InternetConfig_ICChooseConfig); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICChooseConfig)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICChooseConfig(inst)");
    {
	ICInstance	inst;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	RETVAL = ICChooseConfig(inst);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#endif
#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAC 1

XS(XS_Mac__InternetConfig_ICChooseNewConfig); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICChooseNewConfig)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICChooseNewConfig(inst)");
    {
	ICInstance	inst;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 283 "InternetConfig.xs"
	croak("Usage: Mac::InternetConfig::ICChooseNewConfig unsupported in Carbon");
#line 493 "InternetConfig.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1

XS(XS_Mac__InternetConfig_ICChooseNewConfig); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICChooseNewConfig)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICChooseNewConfig(inst)");
    {
	ICInstance	inst;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	RETVAL = ICChooseNewConfig(inst);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#endif
XS(XS_Mac__InternetConfig_ICGetConfigName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetConfigName)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetConfigName(inst, longname=0)");
    {
	ICInstance	inst;
	Boolean	longname;
	Str255	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (items < 2)
	    longname = 0;
	else {
	    longname = (bool)SvTRUE(ST(1));
	}
#line 314 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICGetConfigName(inst, longname, RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 554 "InternetConfig.c"
	XSprePUSH; PUSHp(((char *) RETVAL) + 1, RETVAL[0]);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGetConfigReference); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetConfigReference)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetConfigReference(inst)");
    {
	ICInstance	inst;
	Handle	RETVAL;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 335 "InternetConfig.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::InternetConfig::ICGetConfigReference unsupported in Carbon");
#else
	if (!(RETVAL = NewHandle(0))) {
		XSRETURN_UNDEF;
	}
	if (gMacPerl_OSErr = ICGetConfigReference(inst, (ICConfigRefHandle) RETVAL)) {
		DisposeHandle(RETVAL);
		XSRETURN_UNDEF;
	}
#endif
#line 588 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICSetConfigReference); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICSetConfigReference)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICSetConfigReference(inst, ref, flags=0)");
    {
	ICInstance	inst;
	Handle	ref;
	long	flags;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    ref = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "ref is not of type Handle");

	if (items < 3)
	    flags = 0;
	else {
	    flags = (long)SvIV(ST(2));
	}
#line 371 "InternetConfig.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::InternetConfig::ICSetConfigReference unsupported in Carbon");
#else
	RETVAL = ICSetConfigReference(inst, (ICConfigRefHandle) ref, flags);
#endif
#line 633 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGetSeed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetSeed)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetSeed(inst)");
    {
	ICInstance	inst;
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 393 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICGetSeed(inst, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 660 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGetComponentInstance); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetComponentInstance)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetComponentInstance(inst)");
    {
	ICInstance	inst;
	ComponentInstance	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 414 "InternetConfig.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::InternetConfig::ICGetComponentInstance unsupported in Carbon");
#else
	if (gMacPerl_OSErr = ICGetComponentInstance(inst, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#endif
#line 691 "InternetConfig.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICBegin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICBegin)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICBegin(inst, perm)");
    {
	ICInstance	inst;
	ICPerm	perm = (ICPerm)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	RETVAL = ICBegin(inst, perm);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGetPref); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetPref)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetPref(inst, key)");
    SP -= items;
    {
	ICInstance	inst;
	Str255	key;
#line 461 "InternetConfig.xs"
	ICAttr	attr;
	Handle	pref;
#line 735 "InternetConfig.c"

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), key);
#line 464 "InternetConfig.xs"
	pref = NewHandle(0);
	gMacPerl_OSErr = ICFindPrefHandle(inst, key, &attr, pref);
	if (!gMacPerl_OSErr) 
		if (GIMME != G_ARRAY) {
			XPUSHs(sv_2mortal(MakeHndSV(pref)));
		} else {
			XPUSHs(sv_2mortal(MakeHndSV(pref)));
			XPUSHs(sv_2mortal(newSViv(attr)));
		}
	DisposeHandle(pref);
#line 756 "InternetConfig.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__InternetConfig_ICSetPref); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICSetPref)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICSetPref(inst, key, value, attr=(unsigned long)(kICAttrNoChange))");
    {
	ICInstance	inst;
	Str255	key;
	SV *	value = ST(2);
	ICAttr	attr;
#line 498 "InternetConfig.xs"
	STRLEN	len;
	Ptr		ptr;
	Handle	pref;
#line 777 "InternetConfig.c"
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), key);

	if (items < 4)
	    attr = (unsigned long)(kICAttrNoChange);
	else {
	    attr = (ICAttr)SvIV(ST(3));
	}
#line 502 "InternetConfig.xs"
	ptr = SvPV(value, len);
	RETVAL = PtrToHand(ptr, &pref, len);
	if (!RETVAL) {
		RETVAL = ICSetPrefHandle(inst, key, attr, pref);
		DisposeHandle(pref);
	}
#line 802 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICCountPref); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICCountPref)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICCountPref(inst)");
    {
	ICInstance	inst;
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 523 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICCountPref(inst, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 829 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGetIndPref); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetIndPref)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetIndPref(inst, n)");
    {
	ICInstance	inst;
	long	n = (long)SvIV(ST(1));
	Str255	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");
#line 544 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICGetIndPref(inst, n, RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 857 "InternetConfig.c"
	XSprePUSH; PUSHp(((char *) RETVAL) + 1, RETVAL[0]);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICDeletePref); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICDeletePref)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICDeletePref(inst, key)");
    {
	ICInstance	inst;
	Str255	key;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), key);

	RETVAL = ICDeletePref(inst, key);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICEnd); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICEnd)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICEnd(inst)");
    {
	ICInstance	inst;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	RETVAL = ICEnd(inst);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICEditPreferences); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICEditPreferences)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICEditPreferences(ic, key)");
    {
	ICInstance	ic;
	Str255	key;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ic = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "ic is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), key);

	RETVAL = ICEditPreferences(ic, key);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICParseURL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICParseURL)
{
    dXSARGS;
    if (items < 3 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICParseURL(ic, hint, sv, start=-1, end=-1)");
    SP -= items;
    {
	ICInstance	ic;
	Str255	hint;
	SV *	sv = ST(2);
	long	start;
	long	end;
#line 630 "InternetConfig.xs"
	STRLEN	len;
	Ptr 	data;
	Handle	url;
#line 958 "InternetConfig.c"

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ic = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "ic is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), hint);

	if (items < 4)
	    start = -1;
	else {
	    start = (long)SvIV(ST(3));
	}

	if (items < 5)
	    end = -1;
	else {
	    end = (long)SvIV(ST(4));
	}
#line 634 "InternetConfig.xs"
	url = NewHandle(0);
	data = (Ptr) SvPV(sv, len);
	if (start == -1) {
		start = 0;
		end	  = len;
	} else if (end == -1) 
		end   = start;
	gMacPerl_OSErr = ICParseURL(ic, hint, data, len, &start, &end, url);
	if (!gMacPerl_OSErr) 
		if (GIMME != G_ARRAY) {
			XPUSHs(sv_2mortal(MakeHndSV(url)));
		} else {
			XPUSHs(sv_2mortal(MakeHndSV(url)));
			XPUSHs(sv_2mortal(newSViv(start)));
			XPUSHs(sv_2mortal(newSViv(end)));
		}
	DisposeHandle(url);
#line 998 "InternetConfig.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__InternetConfig_ICLaunchURL); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICLaunchURL)
{
    dXSARGS;
    if (items < 3 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICLaunchURL(ic, hint, sv, start=-1, end=-1)");
    SP -= items;
    {
	ICInstance	ic;
	Str255	hint;
	SV *	sv = ST(2);
	long	start;
	long	end;
#line 680 "InternetConfig.xs"
	STRLEN	len;
	Ptr 	data;
#line 1020 "InternetConfig.c"

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ic = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "ic is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), hint);

	if (items < 4)
	    start = -1;
	else {
	    start = (long)SvIV(ST(3));
	}

	if (items < 5)
	    end = -1;
	else {
	    end = (long)SvIV(ST(4));
	}
#line 683 "InternetConfig.xs"
	data = (Ptr) SvPV(sv, len);
	if (start == -1) {
		start = 0;
		end	  = len;
	} else if (end == -1) 
		end   = start;
	gMacPerl_OSErr = ICLaunchURL(ic, hint, data, len, &start, &end);
	if (!gMacPerl_OSErr) 
		if (GIMME != G_ARRAY) {
			XPUSHs(sv_2mortal(newSViv(1)));
		} else {
			XPUSHs(sv_2mortal(newSViv(start)));
			XPUSHs(sv_2mortal(newSViv(end)));
		}
#line 1057 "InternetConfig.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__InternetConfig_ICMapFilename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICMapFilename)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICMapFilename(inst, filename)");
    {
	ICInstance	inst;
	Str255	filename;
	ICMapEntry	RETVAL;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), filename);
#line 708 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICMapFilename(inst, filename, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1086 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "ICMapEntry", (void*)&RETVAL, sizeof(ICMapEntry));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICMapTypeCreator); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICMapTypeCreator)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICMapTypeCreator(inst, fType, fCreator, filename=NO_INIT)");
    {
	ICInstance	inst;
	OSType	fType;
	OSType	fCreator;
	Str255	filename;
	ICMapEntry	RETVAL;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	memcpy(&fType, SvPV_nolen(ST(1)), sizeof(OSType));
	fType = ntohl(fType);

	memcpy(&fCreator, SvPV_nolen(ST(2)), sizeof(OSType));
	fCreator = ntohl(fCreator);

	if (items >= 4) {
	    MacPerl_CopyC2P(SvPV_nolen(ST(3)), filename);
	}
#line 727 "InternetConfig.xs"
	if (items < 4)
		filename[0] = 0;
	if (gMacPerl_OSErr = ICMapTypeCreator(inst, fType, fCreator, filename, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1128 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "ICMapEntry", (void*)&RETVAL, sizeof(ICMapEntry));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICMapEntriesFilename); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICMapEntriesFilename)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICMapEntriesFilename(inst, entries, filename)");
    {
	ICInstance	inst;
	Handle	entries;
	Str255	filename;
	ICMapEntry	RETVAL;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");

	MacPerl_CopyC2P(SvPV_nolen(ST(2)), filename);
#line 746 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICMapEntriesFilename(inst, entries, filename, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1166 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "ICMapEntry", (void*)&RETVAL, sizeof(ICMapEntry));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICMapEntriesTypeCreator); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICMapEntriesTypeCreator)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICMapEntriesTypeCreator(inst, entries, fType, fCreator, filename=NO_INIT)");
    {
	ICInstance	inst;
	Handle	entries;
	OSType	fType;
	OSType	fCreator;
	Str255	filename;
	ICMapEntry	RETVAL;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");

	memcpy(&fType, SvPV_nolen(ST(2)), sizeof(OSType));
	fType = ntohl(fType);

	memcpy(&fCreator, SvPV_nolen(ST(3)), sizeof(OSType));
	fCreator = ntohl(fCreator);

	if (items >= 5) {
	    MacPerl_CopyC2P(SvPV_nolen(ST(4)), filename);
	}
#line 766 "InternetConfig.xs"
	if (items < 5)
		filename[0] = 0;
	if (gMacPerl_OSErr = ICMapEntriesTypeCreator(inst, entries, fType, fCreator, filename, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1216 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "ICMapEntry", (void*)&RETVAL, sizeof(ICMapEntry));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICCountMapEntries); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICCountMapEntries)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICCountMapEntries(inst, entries)");
    {
	ICInstance	inst;
	Handle	entries;
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");
#line 784 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICCountMapEntries(inst, entries, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1252 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICGetIndMapEntry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetIndMapEntry)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetIndMapEntry(inst, entries, ndx)");
    SP -= items;
    {
	ICInstance	inst;
	Handle	entries;
	long	ndx = (long)SvIV(ST(2));

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");
#line 804 "InternetConfig.xs"
	{
		long		pos;
		ICMapEntry	entry;

		if (gMacPerl_OSErr = ICGetIndMapEntry(inst, entries, ndx, &pos, &entry)) {
			XSRETURN_EMPTY;
		}
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(pos));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "ICMapEntry", (void*)&(entry), sizeof(ICMapEntry));
	}
#line 1300 "InternetConfig.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__InternetConfig_ICGetMapEntry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICGetMapEntry)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICGetMapEntry(inst, entries, pos)");
    {
	ICInstance	inst;
	Handle	entries;
	long	pos = (long)SvIV(ST(2));
	ICMapEntry	RETVAL;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");
#line 826 "InternetConfig.xs"
	if (gMacPerl_OSErr = ICGetMapEntry(inst, entries, pos, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1335 "InternetConfig.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "ICMapEntry", (void*)&RETVAL, sizeof(ICMapEntry));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICSetMapEntry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICSetMapEntry)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICSetMapEntry(inst, entries, pos, entry)");
    {
	ICInstance	inst;
	Handle	entries;
	long	pos = (long)SvIV(ST(2));
	ICMapEntry	entry;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");

	if (sv_isa(ST(3), "ICMapEntry"))
	    memcpy(&entry, SvPV_nolen((SV*)SvRV(ST(3))), sizeof(ICMapEntry));
	else
	    croak("entry is not of type ICMapEntry");

	RETVAL = ICSetMapEntry(inst, entries, pos, &entry);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICDeleteMapEntry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICDeleteMapEntry)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICDeleteMapEntry(inst, entries, pos)");
    {
	ICInstance	inst;
	Handle	entries;
	long	pos = (long)SvIV(ST(2));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");

	RETVAL = ICDeleteMapEntry(inst, entries, pos);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig_ICAddMapEntry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig_ICAddMapEntry)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::ICAddMapEntry(inst, entries, entry)");
    {
	ICInstance	inst;
	Handle	entries;
	ICMapEntry	entry;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");

	if (sv_isa(ST(2), "ICMapEntry"))
	    memcpy(&entry, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(ICMapEntry));
	else
	    croak("entry is not of type ICMapEntry");

	RETVAL = ICAddMapEntry(inst, entries, &entry);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__InternetConfig__ICMapFind); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__InternetConfig__ICMapFind)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::InternetConfig::_ICMapFind(inst, entries, entry)");
    {
	ICInstance	inst;
	Handle	entries;
	ICMapEntry	entry;
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ICInstance")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    inst = INT2PTR(ICInstance,tmp);
	}
	else
	    Perl_croak(aTHX_ "inst is not of type ICInstance");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    entries = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "entries is not of type Handle");

	if (sv_isa(ST(2), "ICMapEntry"))
	    memcpy(&entry, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(ICMapEntry));
	else
	    croak("entry is not of type ICMapEntry");
#line 872 "InternetConfig.xs"
	{
		long		ndx;
		ICMapEntry	ent;

		for (ndx = 0; ICGetIndMapEntry(inst, entries, ndx++, &RETVAL, &ent); )
			if (EqualMapEntries(&entry, &ent))
				goto found;
		XSRETURN_UNDEF;
found:
		;
	}
#line 1495 "InternetConfig.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__InternetConfig); /* prototype to pass -Wmissing-prototypes */
XS(boot_Mac__InternetConfig)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        cv = newXS("ICMapEntry::version", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("ICMapEntry::file_type", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("ICMapEntry::file_creator", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("ICMapEntry::post_creator", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("ICMapEntry::flags", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("ICMapEntry::extension", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("ICMapEntry::creator_app_name", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 6 ; 
        cv = newXS("ICMapEntry::post_app_name", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 7 ; 
        cv = newXS("ICMapEntry::MIME_type", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 8 ; 
        cv = newXS("ICMapEntry::entry_name", XS_Mac__InternetConfig_ICMapEntry, file);
        XSANY.any_i32 = 9 ; 
        newXS("ICMapEntry::new", XS_ICMapEntry_new, file);
        newXS("Mac::InternetConfig::ICStart", XS_Mac__InternetConfig_ICStart, file);
        newXS("Mac::InternetConfig::ICStop", XS_Mac__InternetConfig_ICStop, file);
        newXS("Mac::InternetConfig::ICGeneralFindConfigFile", XS_Mac__InternetConfig_ICGeneralFindConfigFile, file);
#if XSubPPtmpAAAA
        newXS("Mac::InternetConfig::ICChooseConfig", XS_Mac__InternetConfig_ICChooseConfig, file);
#endif
#if XSubPPtmpAAAB
        newXS("Mac::InternetConfig::ICChooseConfig", XS_Mac__InternetConfig_ICChooseConfig, file);
#endif
#if XSubPPtmpAAAC
        newXS("Mac::InternetConfig::ICChooseNewConfig", XS_Mac__InternetConfig_ICChooseNewConfig, file);
#endif
#if XSubPPtmpAAAD
        newXS("Mac::InternetConfig::ICChooseNewConfig", XS_Mac__InternetConfig_ICChooseNewConfig, file);
#endif
        newXS("Mac::InternetConfig::ICGetConfigName", XS_Mac__InternetConfig_ICGetConfigName, file);
        newXS("Mac::InternetConfig::ICGetConfigReference", XS_Mac__InternetConfig_ICGetConfigReference, file);
        newXS("Mac::InternetConfig::ICSetConfigReference", XS_Mac__InternetConfig_ICSetConfigReference, file);
        newXS("Mac::InternetConfig::ICGetSeed", XS_Mac__InternetConfig_ICGetSeed, file);
        newXS("Mac::InternetConfig::ICGetComponentInstance", XS_Mac__InternetConfig_ICGetComponentInstance, file);
        newXS("Mac::InternetConfig::ICBegin", XS_Mac__InternetConfig_ICBegin, file);
        newXS("Mac::InternetConfig::ICGetPref", XS_Mac__InternetConfig_ICGetPref, file);
        newXS("Mac::InternetConfig::ICSetPref", XS_Mac__InternetConfig_ICSetPref, file);
        newXS("Mac::InternetConfig::ICCountPref", XS_Mac__InternetConfig_ICCountPref, file);
        newXS("Mac::InternetConfig::ICGetIndPref", XS_Mac__InternetConfig_ICGetIndPref, file);
        newXS("Mac::InternetConfig::ICDeletePref", XS_Mac__InternetConfig_ICDeletePref, file);
        newXS("Mac::InternetConfig::ICEnd", XS_Mac__InternetConfig_ICEnd, file);
        newXS("Mac::InternetConfig::ICEditPreferences", XS_Mac__InternetConfig_ICEditPreferences, file);
        newXS("Mac::InternetConfig::ICParseURL", XS_Mac__InternetConfig_ICParseURL, file);
        newXS("Mac::InternetConfig::ICLaunchURL", XS_Mac__InternetConfig_ICLaunchURL, file);
        newXS("Mac::InternetConfig::ICMapFilename", XS_Mac__InternetConfig_ICMapFilename, file);
        newXS("Mac::InternetConfig::ICMapTypeCreator", XS_Mac__InternetConfig_ICMapTypeCreator, file);
        newXS("Mac::InternetConfig::ICMapEntriesFilename", XS_Mac__InternetConfig_ICMapEntriesFilename, file);
        newXS("Mac::InternetConfig::ICMapEntriesTypeCreator", XS_Mac__InternetConfig_ICMapEntriesTypeCreator, file);
        newXS("Mac::InternetConfig::ICCountMapEntries", XS_Mac__InternetConfig_ICCountMapEntries, file);
        newXS("Mac::InternetConfig::ICGetIndMapEntry", XS_Mac__InternetConfig_ICGetIndMapEntry, file);
        newXS("Mac::InternetConfig::ICGetMapEntry", XS_Mac__InternetConfig_ICGetMapEntry, file);
        newXS("Mac::InternetConfig::ICSetMapEntry", XS_Mac__InternetConfig_ICSetMapEntry, file);
        newXS("Mac::InternetConfig::ICDeleteMapEntry", XS_Mac__InternetConfig_ICDeleteMapEntry, file);
        newXS("Mac::InternetConfig::ICAddMapEntry", XS_Mac__InternetConfig_ICAddMapEntry, file);
        newXS("Mac::InternetConfig::_ICMapFind", XS_Mac__InternetConfig__ICMapFind, file);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#line 1585 "InternetConfig.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

