/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Sound.xs. Do not edit this file, edit Sound.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Sound.xs"
/* $Header: /home/neeri/MacCVS/MacPerl/perl/ext/Mac/ExtUtils/MakeToolboxModule,v 1.2 1997/11/18 00:52:19 neeri Exp 
 *    Copyright (c) 1997 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: MakeToolboxModule,v  Revision 1.2  1997/11/18 00:52:19  neeri
 * MacPerl 5.1.5
 * 
 * Revision 1.1  1997/04/07 20:49:35  neeri
 * Synchronized with MacPerl 5.1.4a1
 * 
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#endif
#include <Types.h>
#include <Sound.h>

#ifndef __CFM68K__
#include <FixMath.h>
#else
#define fixed1				((Fixed) 0x00010000L)
#define fract1				((Fract) 0x40000000L)
#define positiveInfinity	((long)  0x7FFFFFFFL)
#define negativeInfinity	((long)  0x80000000L)

extern pascal long double Frac2X(Fract x) = 0xA845;
extern pascal long double Fix2X(Fixed x) = 0xA843;
extern pascal Fixed X2Fix(long double x) = 0xA844;
extern pascal Fract X2Frac(long double x) = 0xA846;

#define UnsignedFixedMulDiv(x,y,z)		not_here("UnsignedFixedMulDiv")
#define GetCompressionInfo(x,y,z,a,b)	not_here("GetCompressionInfo")
#define SetSoundPreference(x,y,z)		not_here("SetSoundPreference")
#define GetSoundPreference(x,y,z)		not_here("GetSoundPreference")
#define GetCompressionName(x,y)			not_here("GetCompressionName")
#endif

#define SndChannel	SndChannelPtr

static int
not_here(s)
char *s;
{
    croak("Mac::Sound::%s not implemented in CFM68K (Apple's fault)", s);
    return -1;
}

#line 66 "Sound.c"
XS(XS_Mac__Sound_SndCommand)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SndCommand STRUCT;

#line 66 "Sound.xs"
	 STRUCT;

	if (sv_isa( ST(0), "SndCommand"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(SndCommand));
	else
	    croak(" STRUCT is not of type SndCommand");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* cmd */
#line 67 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.cmd));
		break;
	    case 1:	  /* param1 */
#line 68 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.param1));
		break;
	    case 2:	  /* param2 */
#line 69 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.param2));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* cmd */
#line 67 "Sound.xs"
	 STRUCT.cmd = (unsigned short)SvUV( ST(1));
		break;
	    case 1:	  /* param1 */
#line 68 "Sound.xs"
	 STRUCT.param1 = (short)SvIV( ST(1));
		break;
	    case 2:	  /* param2 */
#line 69 "Sound.xs"
	 STRUCT.param2 = (long)SvIV( ST(1));
		break;
	    }
#line 66 "Sound.xs"
	sv_setref_pvn( ST(0), "SndCommand", (void*)&( STRUCT), sizeof(SndCommand));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SCStatus)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SCStatus STRUCT;

#line 71 "Sound.xs"
	 STRUCT;

	if (sv_isa( ST(0), "SCStatus"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(SCStatus));
	else
	    croak(" STRUCT is not of type SCStatus");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* scStartTime */
#line 72 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setnv(*sp, ((STRUCT.scStartTime) & 0x80000000UL) ? Fix2X((STRUCT.scStartTime))+32768.0 : Fix2X((STRUCT.scStartTime)));
		break;
	    case 1:	  /* scEndTime */
#line 73 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setnv(*sp, ((STRUCT.scEndTime) & 0x80000000UL) ? Fix2X((STRUCT.scEndTime))+32768.0 : Fix2X((STRUCT.scEndTime)));
		break;
	    case 2:	  /* scCurrentTime */
#line 74 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setnv(*sp, ((STRUCT.scCurrentTime) & 0x80000000UL) ? Fix2X((STRUCT.scCurrentTime))+32768.0 : Fix2X((STRUCT.scCurrentTime)));
		break;
	    case 3:	  /* scChannelBusy */
#line 75 "Sound.xs"
	++sp;
	*sp = boolSV((STRUCT.scChannelBusy));
	sv_2mortal(*sp);
		break;
	    case 4:	  /* scChannelDisposed */
#line 76 "Sound.xs"
	++sp;
	*sp = boolSV((STRUCT.scChannelDisposed));
	sv_2mortal(*sp);
		break;
	    case 5:	  /* scChannelPaused */
#line 77 "Sound.xs"
	++sp;
	*sp = boolSV((STRUCT.scChannelPaused));
	sv_2mortal(*sp);
		break;
	    case 6:	  /* scUnused */
#line 78 "Sound.xs"
	++sp;
	*sp = boolSV((STRUCT.scUnused));
	sv_2mortal(*sp);
		break;
	    case 7:	  /* scChannelAttributes */
#line 79 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.scChannelAttributes));
		break;
	    case 8:	  /* scCPULoad */
#line 80 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.scCPULoad));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* scStartTime */
#line 72 "Sound.xs"
	 STRUCT.scStartTime;

	{
		double num = SvNV( ST(1));
		if (num >= 32768.0)
			 STRUCT.scStartTime = X2Fix(num-32768.0) | 0x80000000UL;
		else
			 STRUCT.scStartTime = X2Fix(num);
	};
		break;
	    case 1:	  /* scEndTime */
#line 73 "Sound.xs"
	 STRUCT.scEndTime;

	{
		double num = SvNV( ST(1));
		if (num >= 32768.0)
			 STRUCT.scEndTime = X2Fix(num-32768.0) | 0x80000000UL;
		else
			 STRUCT.scEndTime = X2Fix(num);
	};
		break;
	    case 2:	  /* scCurrentTime */
#line 74 "Sound.xs"
	 STRUCT.scCurrentTime;

	{
		double num = SvNV( ST(1));
		if (num >= 32768.0)
			 STRUCT.scCurrentTime = X2Fix(num-32768.0) | 0x80000000UL;
		else
			 STRUCT.scCurrentTime = X2Fix(num);
	};
		break;
	    case 3:	  /* scChannelBusy */
#line 75 "Sound.xs"
	 STRUCT.scChannelBusy = (bool)SvTRUE( ST(1));
		break;
	    case 4:	  /* scChannelDisposed */
#line 76 "Sound.xs"
	 STRUCT.scChannelDisposed = (bool)SvTRUE( ST(1));
		break;
	    case 5:	  /* scChannelPaused */
#line 77 "Sound.xs"
	 STRUCT.scChannelPaused = (bool)SvTRUE( ST(1));
		break;
	    case 6:	  /* scUnused */
#line 78 "Sound.xs"
	 STRUCT.scUnused = (bool)SvTRUE( ST(1));
		break;
	    case 7:	  /* scChannelAttributes */
#line 79 "Sound.xs"
	 STRUCT.scChannelAttributes = (unsigned long)SvUV( ST(1));
		break;
	    case 8:	  /* scCPULoad */
#line 80 "Sound.xs"
	 STRUCT.scCPULoad = (long)SvIV( ST(1));
		break;
	    }
#line 71 "Sound.xs"
	sv_setref_pvn( ST(0), "SCStatus", (void*)&( STRUCT), sizeof(SCStatus));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SMStatus)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SMStatus STRUCT;

#line 82 "Sound.xs"
	 STRUCT;

	if (sv_isa( ST(0), "SMStatus"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(SMStatus));
	else
	    croak(" STRUCT is not of type SMStatus");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* smMaxCPULoad */
#line 83 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.smMaxCPULoad));
		break;
	    case 1:	  /* smNumChannels */
#line 84 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.smNumChannels));
		break;
	    case 2:	  /* smCurCPULoad */
#line 85 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.smCurCPULoad));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* smMaxCPULoad */
#line 83 "Sound.xs"
	 STRUCT.smMaxCPULoad = (short)SvIV( ST(1));
		break;
	    case 1:	  /* smNumChannels */
#line 84 "Sound.xs"
	 STRUCT.smNumChannels = (short)SvIV( ST(1));
		break;
	    case 2:	  /* smCurCPULoad */
#line 85 "Sound.xs"
	 STRUCT.smCurCPULoad = (short)SvIV( ST(1));
		break;
	    }
#line 82 "Sound.xs"
	sv_setref_pvn( ST(0), "SMStatus", (void*)&( STRUCT), sizeof(SMStatus));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_CompressionInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	CompressionInfo STRUCT;

#line 87 "Sound.xs"
	 STRUCT;

	if (sv_isa( ST(0), "CompressionInfo"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(CompressionInfo));
	else
	    croak(" STRUCT is not of type CompressionInfo");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* recordSize */
#line 88 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.recordSize));
		break;
	    case 1:	  /* format */
#line 89 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT.format));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    case 2:	  /* compressionID */
#line 90 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.compressionID));
		break;
	    case 3:	  /* samplesPerPacket */
#line 91 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.samplesPerPacket));
		break;
	    case 4:	  /* bytesPerPacket */
#line 92 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.bytesPerPacket));
		break;
	    case 5:	  /* bytesPerFrame */
#line 93 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.bytesPerFrame));
		break;
	    case 6:	  /* bytesPerSample */
#line 94 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.bytesPerSample));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* recordSize */
#line 88 "Sound.xs"
	 STRUCT.recordSize = (long)SvIV( ST(1));
		break;
	    case 1:	  /* format */
#line 89 "Sound.xs"
	 STRUCT.format;

	memcpy(& STRUCT.format, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT.format = ntohl( STRUCT.format);
		break;
	    case 2:	  /* compressionID */
#line 90 "Sound.xs"
	 STRUCT.compressionID = (short)SvIV( ST(1));
		break;
	    case 3:	  /* samplesPerPacket */
#line 91 "Sound.xs"
	 STRUCT.samplesPerPacket = (unsigned short)SvUV( ST(1));
		break;
	    case 4:	  /* bytesPerPacket */
#line 92 "Sound.xs"
	 STRUCT.bytesPerPacket = (unsigned short)SvUV( ST(1));
		break;
	    case 5:	  /* bytesPerFrame */
#line 93 "Sound.xs"
	 STRUCT.bytesPerFrame = (unsigned short)SvUV( ST(1));
		break;
	    case 6:	  /* bytesPerSample */
#line 94 "Sound.xs"
	 STRUCT.bytesPerSample = (unsigned short)SvUV( ST(1));
		break;
	    }
#line 87 "Sound.xs"
	sv_setref_pvn( ST(0), "CompressionInfo", (void*)&( STRUCT), sizeof(CompressionInfo));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPB)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SPB STRUCT;

#line 96 "Sound.xs"
	 STRUCT;

	if (sv_isa( ST(0), "SPB"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(SPB));
	else
	    croak(" STRUCT is not of type SPB");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* inRefNum */
#line 97 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.inRefNum));
		break;
	    case 1:	  /* count */
#line 98 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.count));
		break;
	    case 2:	  /* milliseconds */
#line 99 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.milliseconds));
		break;
	    case 3:	  /* bufferLength */
#line 100 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.bufferLength));
		break;
	    case 4:	  /* bufferPtr */
#line 101 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pv(*sp, "Ptr", (void*)(STRUCT.bufferPtr));
		break;
	    case 5:	  /* error */
#line 102 "Sound.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.error));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* inRefNum */
#line 97 "Sound.xs"
	 STRUCT.inRefNum = (long)SvIV( ST(1));
		break;
	    case 1:	  /* count */
#line 98 "Sound.xs"
	 STRUCT.count = (unsigned long)SvUV( ST(1));
		break;
	    case 2:	  /* milliseconds */
#line 99 "Sound.xs"
	 STRUCT.milliseconds = (unsigned long)SvUV( ST(1));
		break;
	    case 3:	  /* bufferLength */
#line 100 "Sound.xs"
	 STRUCT.bufferLength = (unsigned long)SvUV( ST(1));
		break;
	    case 4:	  /* bufferPtr */
#line 101 "Sound.xs"
	 STRUCT.bufferPtr;

	if (sv_derived_from( ST(1), "Ptr")) {
	    IV tmp = SvIV((SV*)SvRV( ST(1)));
	     STRUCT.bufferPtr = INT2PTR(Ptr,tmp);
	}
	else
	    Perl_croak(aTHX_ " STRUCT.bufferPtr is not of type Ptr");
		break;
	    case 5:	  /* error */
#line 102 "Sound.xs"
	 STRUCT.error = (OSErr)SvIV( ST(1));
		break;
	    }
#line 96 "Sound.xs"
	sv_setref_pvn( ST(0), "SPB", (void*)&( STRUCT), sizeof(SPB));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SysBeep); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SysBeep)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SysBeep(duration)");
    {
	short	duration = (short)SvIV(ST(0));

	SysBeep(duration);
    }
    XSRETURN_EMPTY;
}

XS(XS_Mac__Sound_SndDoCommand); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndDoCommand)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndDoCommand(chan, cmd, noWait)");
    {
	SndChannel	chan;
	SndCommand	cmd;
	Boolean	noWait = (bool)SvTRUE(ST(2));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	if (sv_isa(ST(1), "SndCommand"))
	    memcpy(&cmd, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(SndCommand));
	else
	    croak("cmd is not of type SndCommand");

	RETVAL = SndDoCommand(chan, &cmd, noWait);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndDoImmediate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndDoImmediate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndDoImmediate(chan, cmd)");
    {
	SndChannel	chan;
	SndCommand	cmd;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	if (sv_isa(ST(1), "SndCommand"))
	    memcpy(&cmd, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(SndCommand));
	else
	    croak("cmd is not of type SndCommand");

	RETVAL = SndDoImmediate(chan, &cmd);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndNewChannel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndNewChannel)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndNewChannel(synth, init, callback=0)");
    {
	short	synth = (short)SvIV(ST(0));
	long	init = (long)SvIV(ST(1));
	SV *	callback;
	SndChannel	RETVAL;

	if (items < 3)
	    callback = 0;
	else {
	    callback = ST(2);
	}
#line 135 "Sound.xs"
	RETVAL = nil;
	if (gMacPerl_OSErr = SndNewChannel(&RETVAL, synth, init, nil)) {
		XSRETURN_UNDEF;
	}
#line 630 "Sound.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "SndChannel", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndDisposeChannel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndDisposeChannel)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndDisposeChannel(chan, quietNow=false)");
    {
	SndChannel	chan;
	Boolean	quietNow;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	if (items < 2)
	    quietNow = false;
	else {
	    quietNow = (bool)SvTRUE(ST(1));
	}

	RETVAL = SndDisposeChannel(chan, quietNow);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound__SndPlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound__SndPlay)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::_SndPlay(chan, sndHandle, async=false)");
    {
	SndChannel	chan;
	Handle	sndHandle;
	Boolean	async;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    sndHandle = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "sndHandle is not of type Handle");

	if (items < 3)
	    async = false;
	else {
	    async = (bool)SvTRUE(ST(2));
	}
#line 153 "Sound.xs"
	RETVAL = SndPlay(chan, (SndListHandle)sndHandle, async);
#line 702 "Sound.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndControl); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndControl)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndControl(id, cmd)");
    {
	short	id = (short)SvIV(ST(0));
	SndCommand	cmd;
	SndCommand	RETVAL;

	if (sv_isa(ST(1), "SndCommand"))
	    memcpy(&cmd, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(SndCommand));
	else
	    croak("cmd is not of type SndCommand");
#line 162 "Sound.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::SndControl unsupported in Carbon");
#else
	RETVAL = cmd;
	if (gMacPerl_OSErr = SndControl(id, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#endif
#line 732 "Sound.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "SndCommand", (void*)&RETVAL, sizeof(SndCommand));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndSoundManagerVersion); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndSoundManagerVersion)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndSoundManagerVersion()");
    {
	NumVersion	RETVAL;

	RETVAL = SndSoundManagerVersion();
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "NumVersion", (void*)&RETVAL, sizeof(NumVersion));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndStartFilePlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndStartFilePlay)
{
    dXSARGS;
    if (items < 5 || items > 7)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndStartFilePlay(chan, fRefNum, resNum, bufferSize, theSelection, theCompletion=0, async=false)");
    {
	SndChannel	chan;
	short	fRefNum = (short)SvIV(ST(1));
	short	resNum = (short)SvIV(ST(2));
	long	bufferSize = (long)SvIV(ST(3));
	AudioSelection	theSelection;
	SV *	theCompletion;
	Boolean	async;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	if (sv_isa(ST(4), "AudioSelection"))
	    memcpy(&theSelection, SvPV_nolen((SV*)SvRV(ST(4))), sizeof(AudioSelection));
	else
	    croak("theSelection is not of type AudioSelection");

	if (items < 6)
	    theCompletion = 0;
	else {
	    theCompletion = ST(5);
	}

	if (items < 7)
	    async = false;
	else {
	    async = (bool)SvTRUE(ST(6));
	}
#line 186 "Sound.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::SndStartFilePlay unsupported in Carbon");
#else
	RETVAL =
		SndStartFilePlay(
			chan, fRefNum, resNum, bufferSize, nil, &theSelection, nil, async);
#endif
#line 803 "Sound.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAA 1

XS(XS_Mac__Sound_SndPauseFilePlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndPauseFilePlay)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndPauseFilePlay(chan)");
    {
	SndChannel	chan;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");
#line 202 "Sound.xs"
	croak("Usage: Mac::Sound::SndPauseFilePlay unsupported in Carbon");
#line 831 "Sound.c"
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndStopFilePlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndStopFilePlay)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndStopFilePlay(chan, quietNow)");
    {
	SndChannel	chan;
	Boolean	quietNow = (bool)SvTRUE(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");
#line 209 "Sound.xs"
	croak("Usage: Mac::Sound::SndStopFilePlay unsupported in Carbon");
#line 856 "Sound.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAB 1

XS(XS_Mac__Sound_SndPauseFilePlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndPauseFilePlay)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndPauseFilePlay(chan)");
    {
	SndChannel	chan;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	RETVAL = SndPauseFilePlay(chan);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndStopFilePlay); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndStopFilePlay)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndStopFilePlay(chan, quietNow)");
    {
	SndChannel	chan;
	Boolean	quietNow = (bool)SvTRUE(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");

	RETVAL = SndStopFilePlay(chan, quietNow);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#endif
XS(XS_Mac__Sound_SndChannelStatus); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndChannelStatus)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndChannelStatus(chan)");
    {
	SndChannel	chan;
	SCStatus	RETVAL;

	if (sv_derived_from(ST(0), "SndChannel")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    chan = INT2PTR(SndChannel,tmp);
	}
	else
	    Perl_croak(aTHX_ "chan is not of type SndChannel");
#line 228 "Sound.xs"
	if (gMacPerl_OSErr = SndChannelStatus(chan, sizeof(RETVAL), &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 934 "Sound.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "SCStatus", (void*)&RETVAL, sizeof(SCStatus));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndManagerStatus); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndManagerStatus)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndManagerStatus()");
    {
	SMStatus	RETVAL;
#line 237 "Sound.xs"
	if (gMacPerl_OSErr = SndManagerStatus(sizeof(RETVAL), &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 953 "Sound.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "SMStatus", (void*)&RETVAL, sizeof(SMStatus));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndGetSysBeepState); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndGetSysBeepState)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndGetSysBeepState()");
    {
	short	RETVAL;
	dXSTARG;
#line 246 "Sound.xs"
	SndGetSysBeepState(&RETVAL);
#line 971 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndSetSysBeepState); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndSetSysBeepState)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndSetSysBeepState(sysBeepState)");
    {
	short	sysBeepState = (short)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SndSetSysBeepState(sysBeepState);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAC 1

XS(XS_Mac__Sound_MACEVersion); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_MACEVersion)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::MACEVersion()");
    {
	NumVersion	RETVAL;
#line 270 "Sound.xs"
	croak("Usage: Mac::Sound::MACEVersion unsupported in Carbon");
#line 1007 "Sound.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1

XS(XS_Mac__Sound_MACEVersion); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_MACEVersion)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::MACEVersion()");
    {
	NumVersion	RETVAL;

	RETVAL = MACEVersion();
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "NumVersion", (void*)&RETVAL, sizeof(NumVersion));
    }
    XSRETURN(1);
}

#endif
XS(XS_Mac__Sound_Comp3to1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_Comp3to1)
{
    dXSARGS;
    if (items < 1 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::Sound::Comp3to1(inBuffer, inState=NO_INIT, numChannels=1, whichChannel=1)");
    SP -= items;
    {
	SV *	inBuffer = ST(0);
	StateBlock	inState;
	unsigned long	numChannels;
	unsigned long	whichChannel;

	if (items >= 2) {
	    if (sv_isa(ST(1), "StateBlock"))
		memcpy(&inState, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(StateBlock));
	    else
		croak("inState is not of type StateBlock");
	}

	if (items < 3)
	    numChannels = 1;
	else {
	    numChannels = (unsigned long)SvUV(ST(2));
	}

	if (items < 4)
	    whichChannel = 1;
	else {
	    whichChannel = (unsigned long)SvUV(ST(3));
	}
#line 286 "Sound.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::Comp3to1 unsupported in Carbon");
#else
		unsigned long 	cnt = SvCUR(inBuffer);
		SV *			outBuffer = newSVpv("", cnt / 3);
		StateBlock		outState;
		Comp3to1(
			SvPV_nolen(inBuffer), SvPV_nolen(outBuffer), cnt, 
			(items > 1) ? &inState : nil, &outState, numChannels, whichChannel);
		PUSHs(sv_2mortal(outBuffer));
		if (GIMME == G_ARRAY) {
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "StateBlock", (void*)&(outState), sizeof(StateBlock));
		}
#endif
	}
#line 1082 "Sound.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Sound_Exp1to3); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_Exp1to3)
{
    dXSARGS;
    if (items < 1 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::Sound::Exp1to3(inBuffer, inState=NO_INIT, numChannels=1, whichChannel=1)");
    SP -= items;
    {
	SV *	inBuffer = ST(0);
	StateBlock	inState;
	unsigned long	numChannels;
	unsigned long	whichChannel;

	if (items >= 2) {
	    if (sv_isa(ST(1), "StateBlock"))
		memcpy(&inState, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(StateBlock));
	    else
		croak("inState is not of type StateBlock");
	}

	if (items < 3)
	    numChannels = 1;
	else {
	    numChannels = (unsigned long)SvUV(ST(2));
	}

	if (items < 4)
	    whichChannel = 1;
	else {
	    whichChannel = (unsigned long)SvUV(ST(3));
	}
#line 310 "Sound.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::Exp1to3 unsupported in Carbon");
#else
		unsigned long 	cnt = SvCUR(inBuffer) / 2;
		SV *			outBuffer = newSVpv("", cnt*6);
		StateBlock		outState;
		Exp1to3(
			SvPV_nolen(inBuffer), SvPV_nolen(outBuffer), cnt, 
			(items > 1) ? &inState : nil, &outState, numChannels, whichChannel);
		PUSHs(sv_2mortal(outBuffer));
		if (GIMME == G_ARRAY) {
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "StateBlock", (void*)&(outState), sizeof(StateBlock));
		}
#endif
	}
#line 1138 "Sound.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Sound_Comp6to1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_Comp6to1)
{
    dXSARGS;
    if (items < 1 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::Sound::Comp6to1(inBuffer, inState=NO_INIT, numChannels=1, whichChannel=1)");
    SP -= items;
    {
	SV *	inBuffer = ST(0);
	StateBlock	inState;
	unsigned long	numChannels;
	unsigned long	whichChannel;

	if (items >= 2) {
	    if (sv_isa(ST(1), "StateBlock"))
		memcpy(&inState, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(StateBlock));
	    else
		croak("inState is not of type StateBlock");
	}

	if (items < 3)
	    numChannels = 1;
	else {
	    numChannels = (unsigned long)SvUV(ST(2));
	}

	if (items < 4)
	    whichChannel = 1;
	else {
	    whichChannel = (unsigned long)SvUV(ST(3));
	}
#line 334 "Sound.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::Comp6to1 unsupported in Carbon");
#else
		unsigned long 	cnt = SvCUR(inBuffer);
		SV *			outBuffer = newSVpv("", cnt / 6);
		StateBlock		outState;
		Comp6to1(
			SvPV_nolen(inBuffer), SvPV_nolen(outBuffer), cnt, 
			(items > 1) ? &inState : nil, &outState, numChannels, whichChannel);
		PUSHs(sv_2mortal(outBuffer));
		if (GIMME == G_ARRAY) {
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "StateBlock", (void*)&(outState), sizeof(StateBlock));
		}
#endif
	}
#line 1194 "Sound.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Sound_Exp1to6); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_Exp1to6)
{
    dXSARGS;
    if (items < 1 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::Sound::Exp1to6(inBuffer, inState=NO_INIT, numChannels=1, whichChannel=1)");
    SP -= items;
    {
	SV *	inBuffer = ST(0);
	StateBlock	inState;
	unsigned long	numChannels;
	unsigned long	whichChannel;

	if (items >= 2) {
	    if (sv_isa(ST(1), "StateBlock"))
		memcpy(&inState, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(StateBlock));
	    else
		croak("inState is not of type StateBlock");
	}

	if (items < 3)
	    numChannels = 1;
	else {
	    numChannels = (unsigned long)SvUV(ST(2));
	}

	if (items < 4)
	    whichChannel = 1;
	else {
	    whichChannel = (unsigned long)SvUV(ST(3));
	}
#line 358 "Sound.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::Exp1to6 unsupported in Carbon");
#else
		unsigned long 	cnt = SvCUR(inBuffer);
		SV *			outBuffer = newSVpv("", cnt * 6);
		StateBlock		outState;
		Exp1to6(
			SvPV_nolen(inBuffer), SvPV_nolen(outBuffer), cnt, 
			(items > 1) ? &inState : nil, &outState, numChannels, whichChannel);
		PUSHs(sv_2mortal(outBuffer));
		if (GIMME == G_ARRAY) {
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "StateBlock", (void*)&(outState), sizeof(StateBlock));
		}
#endif
	}
#line 1250 "Sound.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Sound_GetSysBeepVolume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_GetSysBeepVolume)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::GetSysBeepVolume()");
    {
	long	RETVAL;
	dXSTARG;
#line 378 "Sound.xs"
	if (gMacPerl_OSErr = GetSysBeepVolume(&RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1269 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SetSysBeepVolume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SetSysBeepVolume)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SetSysBeepVolume(level)");
    {
	long	level = (long)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SetSysBeepVolume(level);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_GetDefaultOutputVolume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_GetDefaultOutputVolume)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::GetDefaultOutputVolume()");
    {
	long	RETVAL;
	dXSTARG;
#line 391 "Sound.xs"
	if (gMacPerl_OSErr = GetDefaultOutputVolume(&RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1305 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SetDefaultOutputVolume); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SetDefaultOutputVolume)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SetDefaultOutputVolume(level)");
    {
	long	level = (long)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SetDefaultOutputVolume(level);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_GetSoundHeaderOffset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_GetSoundHeaderOffset)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::GetSoundHeaderOffset(sndHandle)");
    {
	Handle	sndHandle;
	long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sndHandle = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "sndHandle is not of type Handle");
#line 405 "Sound.xs"
	if (gMacPerl_OSErr = GetSoundHeaderOffset((SndListHandle)sndHandle, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1349 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_UnsignedFixedMulDiv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_UnsignedFixedMulDiv)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::UnsignedFixedMulDiv(value, multiplier, divisor)");
    {
	UnsignedFixed	value;
	UnsignedFixed	multiplier;
	UnsignedFixed	divisor;
	UnsignedFixed	RETVAL;
	dXSTARG;

	{
		double num = SvNV(ST(0));
		if (num >= 32768.0)
			value = X2Fix(num-32768.0) | 0x80000000UL;
		else
			value = X2Fix(num);
	};

	{
		double num = SvNV(ST(1));
		if (num >= 32768.0)
			multiplier = X2Fix(num-32768.0) | 0x80000000UL;
		else
			multiplier = X2Fix(num);
	};

	{
		double num = SvNV(ST(2));
		if (num >= 32768.0)
			divisor = X2Fix(num-32768.0) | 0x80000000UL;
		else
			divisor = X2Fix(num);
	};

	RETVAL = UnsignedFixedMulDiv(value, multiplier, divisor);
	XSprePUSH; PUSHn((RETVAL & 0x80000000UL) ? Fix2X(RETVAL)+32768.0 : Fix2X(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_GetCompressionInfo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_GetCompressionInfo)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::Sound::GetCompressionInfo(compressionID, format, numChannels, sampleSize)");
    {
	short	compressionID = (short)SvIV(ST(0));
	OSType	format;
	short	numChannels = (short)SvIV(ST(2));
	short	sampleSize = (short)SvIV(ST(3));
	CompressionInfo	RETVAL;

	memcpy(&format, SvPV_nolen(ST(1)), sizeof(OSType));
	format = ntohl(format);
#line 424 "Sound.xs"
	if (gMacPerl_OSErr = 
		GetCompressionInfo(
			compressionID, format, numChannels, sampleSize, &RETVAL)
	) {
		XSRETURN_UNDEF;
	}
#line 1420 "Sound.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "CompressionInfo", (void*)&RETVAL, sizeof(CompressionInfo));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SetSoundPreference); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SetSoundPreference)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SetSoundPreference(theType, name, settings)");
    {
	OSType	theType;
	Str255	name;
	Handle	settings;
	MacOSRet	RETVAL;
	dXSTARG;

	memcpy(&theType, SvPV_nolen(ST(0)), sizeof(OSType));
	theType = ntohl(theType);

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), name);

	if (sv_derived_from(ST(2), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    settings = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "settings is not of type Handle");

	RETVAL = SetSoundPreference(theType, name, settings);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound__GetSoundPreference); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound__GetSoundPreference)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::_GetSoundPreference(theType, name, settings)");
    {
	OSType	theType;
	Str255	name;
	Handle	settings;
	MacOSRet	RETVAL;
	dXSTARG;

	memcpy(&theType, SvPV_nolen(ST(0)), sizeof(OSType));
	theType = ntohl(theType);

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), name);

	if (sv_derived_from(ST(2), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    settings = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "settings is not of type Handle");
#line 445 "Sound.xs"
	RETVAL = GetSoundPreference(theType, name, settings);
#line 1484 "Sound.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_GetCompressionName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_GetCompressionName)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::GetCompressionName(compressionType)");
    {
	OSType	compressionType;
	Str255	RETVAL;
	dXSTARG;

	memcpy(&compressionType, SvPV_nolen(ST(0)), sizeof(OSType));
	compressionType = ntohl(compressionType);
#line 493 "Sound.xs"
	if (gMacPerl_OSErr = GetCompressionName(compressionType, RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1507 "Sound.c"
	XSprePUSH; PUSHp(((char *) RETVAL) + 1, RETVAL[0]);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBVersion); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBVersion)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBVersion()");
    {
	NumVersion	RETVAL;

	RETVAL = SPBVersion();
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "NumVersion", (void*)&RETVAL, sizeof(NumVersion));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndRecord); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndRecord)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndRecord(filterProc, corner, quality)");
    {
	SV *	filterProc = ST(0);
	Point	corner;
	OSType	quality;
	Handle	RETVAL;

	if (sv_isa(ST(1), "Point"))
	    memcpy(&corner, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(Point));
	else
	    croak("corner is not of type Point");

	memcpy(&quality, SvPV_nolen(ST(2)), sizeof(OSType));
	quality = ntohl(quality);
#line 553 "Sound.xs"
	{
		RETVAL = nil;
		if (gMacPerl_OSErr = 
			SndRecord(nil, corner, quality, (SndListHandle *)&RETVAL)
		) {
			XSRETURN_UNDEF;
		}
	}
#line 1557 "Sound.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SndRecordToFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SndRecordToFile)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SndRecordToFile(filterProc, corner, quality, fRefNum)");
    {
	SV *	filterProc = ST(0);
	Point	corner;
	OSType	quality;
	short	fRefNum = (short)SvIV(ST(3));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(1), "Point"))
	    memcpy(&corner, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(Point));
	else
	    croak("corner is not of type Point");

	memcpy(&quality, SvPV_nolen(ST(2)), sizeof(OSType));
	quality = ntohl(quality);
#line 571 "Sound.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Sound::SndRecordToFile unsupported in Carbon");
#else
	RETVAL = SndRecordToFile(nil, corner, quality, fRefNum);
#endif
#line 1591 "Sound.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBSignInDevice); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBSignInDevice)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBSignInDevice(deviceRefNum, deviceName)");
    {
	short	deviceRefNum = (short)SvIV(ST(0));
	Str255	deviceName;
	MacOSRet	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), deviceName);

	RETVAL = SPBSignInDevice(deviceRefNum, deviceName);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBSignOutDevice); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBSignOutDevice)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBSignOutDevice(deviceRefNum)");
    {
	short	deviceRefNum = (short)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SPBSignOutDevice(deviceRefNum);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBGetIndexedDevice); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBGetIndexedDevice)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBGetIndexedDevice(count)");
    SP -= items;
    {
	short	count = (short)SvIV(ST(0));
#line 592 "Sound.xs"
	{
		Str255	name;
		Handle 	icon;

		if (gMacPerl_OSErr = SPBGetIndexedDevice(count, name, &icon)) {
			XSRETURN_UNDEF;
		}
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (name)) + 1, (name)[0]);
		if (GIMME == G_ARRAY) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setref_pv(*sp, "Handle", (void*)(icon));
		} else {
			DisposeHandle(icon);
		}
	}
#line 1663 "Sound.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Sound_SPBOpenDevice); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBOpenDevice)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBOpenDevice(deviceName, permission)");
    {
	Str255	deviceName;
	short	permission = (short)SvIV(ST(1));
	long	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(0)), deviceName);
#line 612 "Sound.xs"
	if (gMacPerl_OSErr = SPBOpenDevice(deviceName, permission, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1686 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBCloseDevice); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBCloseDevice)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBCloseDevice(inRefNum)");
    {
	long	inRefNum = (long)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SPBCloseDevice(inRefNum);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBRecord); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBRecord)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBRecord(inParamPtr, asynchFlag=false)");
    {
	SPB	inParamPtr;
	Boolean	asynchFlag;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "SPB"))
	    memcpy(&inParamPtr, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(SPB));
	else
	    croak("inParamPtr is not of type SPB");

	if (items < 2)
	    asynchFlag = false;
	else {
	    asynchFlag = (bool)SvTRUE(ST(1));
	}

	RETVAL = SPBRecord(&inParamPtr, asynchFlag);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAE 1

XS(XS_Mac__Sound_SPBRecordToFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBRecordToFile)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBRecordToFile(fRefNum, inParamPtr, asynchFlag=false)");
    {
	short	fRefNum = (short)SvIV(ST(0));
	SPB	inParamPtr;
	Boolean	asynchFlag;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(1), "SPB"))
	    memcpy(&inParamPtr, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(SPB));
	else
	    croak("inParamPtr is not of type SPB");

	if (items < 3)
	    asynchFlag = false;
	else {
	    asynchFlag = (bool)SvTRUE(ST(2));
	}
#line 635 "Sound.xs"
	croak("Usage: Mac::Sound::SPBRecordToFile unsupported in Carbon");
#line 1766 "Sound.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1

XS(XS_Mac__Sound_SPBRecordToFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBRecordToFile)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBRecordToFile(fRefNum, inParamPtr, asynchFlag=false)");
    {
	short	fRefNum = (short)SvIV(ST(0));
	SPB	inParamPtr;
	Boolean	asynchFlag;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(1), "SPB"))
	    memcpy(&inParamPtr, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(SPB));
	else
	    croak("inParamPtr is not of type SPB");

	if (items < 3)
	    asynchFlag = false;
	else {
	    asynchFlag = (bool)SvTRUE(ST(2));
	}

	RETVAL = SPBRecordToFile(fRefNum, &inParamPtr, asynchFlag);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#endif
XS(XS_Mac__Sound_SPBPauseRecording); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBPauseRecording)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBPauseRecording(inRefNum)");
    {
	long	inRefNum = (long)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SPBPauseRecording(inRefNum);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBResumeRecording); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBResumeRecording)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBResumeRecording(inRefNum)");
    {
	long	inRefNum = (long)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SPBResumeRecording(inRefNum);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBStopRecording); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBStopRecording)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBStopRecording(inRefNum)");
    {
	long	inRefNum = (long)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SPBStopRecording(inRefNum);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBGetRecordingStatus); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBGetRecordingStatus)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBGetRecordingStatus(inRefNum)");
    SP -= items;
    {
	long	inRefNum = (long)SvIV(ST(0));
#line 663 "Sound.xs"
	{
		short recordingStatus;
		short meterLevel;
		unsigned long totalSamplesToRecord;
		unsigned long numberOfSamplesRecorded;
		unsigned long totalMsecsToRecord;
		unsigned long numberOfMsecsRecorded;

		if (gMacPerl_OSErr = 
			SPBGetRecordingStatus(
				inRefNum, &recordingStatus, &meterLevel,
				&totalSamplesToRecord, &numberOfSamplesRecorded,
				&totalMsecsToRecord, &numberOfMsecsRecorded)
		) {
			XSRETURN_EMPTY;
		}
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(recordingStatus));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(meterLevel));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(totalSamplesToRecord));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(numberOfSamplesRecorded));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(totalMsecsToRecord));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(numberOfMsecsRecorded));
	}
#line 1907 "Sound.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Sound_SPBMillisecondsToBytes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBMillisecondsToBytes)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBMillisecondsToBytes(inRefNum)");
    {
	long	inRefNum = (long)SvIV(ST(0));
	long	RETVAL;
	dXSTARG;
#line 708 "Sound.xs"
	if (gMacPerl_OSErr = SPBMillisecondsToBytes(inRefNum, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1927 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SPBBytesToMilliseconds); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SPBBytesToMilliseconds)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SPBBytesToMilliseconds(inRefNum)");
    {
	long	inRefNum = (long)SvIV(ST(0));
	long	RETVAL;
	dXSTARG;
#line 718 "Sound.xs"
	if (gMacPerl_OSErr = SPBBytesToMilliseconds(inRefNum, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1947 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SetupSndHeader); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SetupSndHeader)
{
    dXSARGS;
    if (items != 7)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SetupSndHeader(sndHandle, numChannels, sampleRate, sampleSize, compressionType, baseNote, numBytes)");
    {
	Handle	sndHandle;
	short	numChannels = (short)SvIV(ST(1));
	UnsignedFixed	sampleRate;
	short	sampleSize = (short)SvIV(ST(3));
	OSType	compressionType;
	short	baseNote = (short)SvIV(ST(5));
	unsigned long	numBytes = (unsigned long)SvUV(ST(6));
	short	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sndHandle = INT2PTR(Handle,tmp);
	}
	else
	    Perl_croak(aTHX_ "sndHandle is not of type Handle");

	{
		double num = SvNV(ST(2));
		if (num >= 32768.0)
			sampleRate = X2Fix(num-32768.0) | 0x80000000UL;
		else
			sampleRate = X2Fix(num);
	};

	memcpy(&compressionType, SvPV_nolen(ST(4)), sizeof(OSType));
	compressionType = ntohl(compressionType);
#line 734 "Sound.xs"
	if (gMacPerl_OSErr = 
		SetupSndHeader(
			(SndListHandle)sndHandle, numChannels, sampleRate, sampleSize, 
			compressionType, baseNote, numBytes, &RETVAL)
	) {
		XSRETURN_UNDEF;
	}
#line 1995 "Sound.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Sound_SetupAIFFHeader); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Sound_SetupAIFFHeader)
{
    dXSARGS;
    if (items != 7)
	Perl_croak(aTHX_ "Usage: Mac::Sound::SetupAIFFHeader(fRefNum, numChannels, sampleRate, sampleSize, compressionType, numBytes, numFrames)");
    {
	short	fRefNum = (short)SvIV(ST(0));
	short	numChannels = (short)SvIV(ST(1));
	UnsignedFixed	sampleRate;
	short	sampleSize = (short)SvIV(ST(3));
	OSType	compressionType;
	unsigned long	numBytes = (unsigned long)SvUV(ST(5));
	unsigned long	numFrames = (unsigned long)SvUV(ST(6));
	MacOSRet	RETVAL;
	dXSTARG;

	{
		double num = SvNV(ST(2));
		if (num >= 32768.0)
			sampleRate = X2Fix(num-32768.0) | 0x80000000UL;
		else
			sampleRate = X2Fix(num);
	};

	memcpy(&compressionType, SvPV_nolen(ST(4)), sizeof(OSType));
	compressionType = ntohl(compressionType);

	RETVAL = SetupAIFFHeader(fRefNum, numChannels, sampleRate, sampleSize, compressionType, numBytes, numFrames);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__Sound); /* prototype to pass -Wmissing-prototypes */
XS(boot_Mac__Sound)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        cv = newXS("SndCommand::cmd", XS_Mac__Sound_SndCommand, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("SndCommand::param1", XS_Mac__Sound_SndCommand, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("SndCommand::param2", XS_Mac__Sound_SndCommand, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("SCStatus::scStartTime", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("SCStatus::scEndTime", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("SCStatus::scCurrentTime", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("SCStatus::scChannelBusy", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("SCStatus::scChannelDisposed", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("SCStatus::scChannelPaused", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("SCStatus::scUnused", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 6 ; 
        cv = newXS("SCStatus::scChannelAttributes", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 7 ; 
        cv = newXS("SCStatus::scCPULoad", XS_Mac__Sound_SCStatus, file);
        XSANY.any_i32 = 8 ; 
        cv = newXS("SMStatus::smMaxCPULoad", XS_Mac__Sound_SMStatus, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("SMStatus::smNumChannels", XS_Mac__Sound_SMStatus, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("SMStatus::smCurCPULoad", XS_Mac__Sound_SMStatus, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("CompressionInfo::recordSize", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("CompressionInfo::format", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("CompressionInfo::compressionID", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("CompressionInfo::samplesPerPacket", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("CompressionInfo::bytesPerPacket", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("CompressionInfo::bytesPerFrame", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("CompressionInfo::bytesPerSample", XS_Mac__Sound_CompressionInfo, file);
        XSANY.any_i32 = 6 ; 
        cv = newXS("SPB::inRefNum", XS_Mac__Sound_SPB, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("SPB::count", XS_Mac__Sound_SPB, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("SPB::milliseconds", XS_Mac__Sound_SPB, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("SPB::bufferLength", XS_Mac__Sound_SPB, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("SPB::bufferPtr", XS_Mac__Sound_SPB, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("SPB::error", XS_Mac__Sound_SPB, file);
        XSANY.any_i32 = 5 ; 
        newXS("Mac::Sound::SysBeep", XS_Mac__Sound_SysBeep, file);
        newXS("Mac::Sound::SndDoCommand", XS_Mac__Sound_SndDoCommand, file);
        newXS("Mac::Sound::SndDoImmediate", XS_Mac__Sound_SndDoImmediate, file);
        newXS("Mac::Sound::SndNewChannel", XS_Mac__Sound_SndNewChannel, file);
        newXS("Mac::Sound::SndDisposeChannel", XS_Mac__Sound_SndDisposeChannel, file);
        newXS("Mac::Sound::_SndPlay", XS_Mac__Sound__SndPlay, file);
        newXS("Mac::Sound::SndControl", XS_Mac__Sound_SndControl, file);
        newXS("Mac::Sound::SndSoundManagerVersion", XS_Mac__Sound_SndSoundManagerVersion, file);
        newXS("Mac::Sound::SndStartFilePlay", XS_Mac__Sound_SndStartFilePlay, file);
#if XSubPPtmpAAAA
        newXS("Mac::Sound::SndPauseFilePlay", XS_Mac__Sound_SndPauseFilePlay, file);
        newXS("Mac::Sound::SndStopFilePlay", XS_Mac__Sound_SndStopFilePlay, file);
#endif
#if XSubPPtmpAAAB
        newXS("Mac::Sound::SndPauseFilePlay", XS_Mac__Sound_SndPauseFilePlay, file);
        newXS("Mac::Sound::SndStopFilePlay", XS_Mac__Sound_SndStopFilePlay, file);
#endif
        newXS("Mac::Sound::SndChannelStatus", XS_Mac__Sound_SndChannelStatus, file);
        newXS("Mac::Sound::SndManagerStatus", XS_Mac__Sound_SndManagerStatus, file);
        newXS("Mac::Sound::SndGetSysBeepState", XS_Mac__Sound_SndGetSysBeepState, file);
        newXS("Mac::Sound::SndSetSysBeepState", XS_Mac__Sound_SndSetSysBeepState, file);
#if XSubPPtmpAAAC
        newXS("Mac::Sound::MACEVersion", XS_Mac__Sound_MACEVersion, file);
#endif
#if XSubPPtmpAAAD
        newXS("Mac::Sound::MACEVersion", XS_Mac__Sound_MACEVersion, file);
#endif
        newXS("Mac::Sound::Comp3to1", XS_Mac__Sound_Comp3to1, file);
        newXS("Mac::Sound::Exp1to3", XS_Mac__Sound_Exp1to3, file);
        newXS("Mac::Sound::Comp6to1", XS_Mac__Sound_Comp6to1, file);
        newXS("Mac::Sound::Exp1to6", XS_Mac__Sound_Exp1to6, file);
        newXS("Mac::Sound::GetSysBeepVolume", XS_Mac__Sound_GetSysBeepVolume, file);
        newXS("Mac::Sound::SetSysBeepVolume", XS_Mac__Sound_SetSysBeepVolume, file);
        newXS("Mac::Sound::GetDefaultOutputVolume", XS_Mac__Sound_GetDefaultOutputVolume, file);
        newXS("Mac::Sound::SetDefaultOutputVolume", XS_Mac__Sound_SetDefaultOutputVolume, file);
        newXS("Mac::Sound::GetSoundHeaderOffset", XS_Mac__Sound_GetSoundHeaderOffset, file);
        newXS("Mac::Sound::UnsignedFixedMulDiv", XS_Mac__Sound_UnsignedFixedMulDiv, file);
        newXS("Mac::Sound::GetCompressionInfo", XS_Mac__Sound_GetCompressionInfo, file);
        newXS("Mac::Sound::SetSoundPreference", XS_Mac__Sound_SetSoundPreference, file);
        newXS("Mac::Sound::_GetSoundPreference", XS_Mac__Sound__GetSoundPreference, file);
        newXS("Mac::Sound::GetCompressionName", XS_Mac__Sound_GetCompressionName, file);
        newXS("Mac::Sound::SPBVersion", XS_Mac__Sound_SPBVersion, file);
        newXS("Mac::Sound::SndRecord", XS_Mac__Sound_SndRecord, file);
        newXS("Mac::Sound::SndRecordToFile", XS_Mac__Sound_SndRecordToFile, file);
        newXS("Mac::Sound::SPBSignInDevice", XS_Mac__Sound_SPBSignInDevice, file);
        newXS("Mac::Sound::SPBSignOutDevice", XS_Mac__Sound_SPBSignOutDevice, file);
        newXS("Mac::Sound::SPBGetIndexedDevice", XS_Mac__Sound_SPBGetIndexedDevice, file);
        newXS("Mac::Sound::SPBOpenDevice", XS_Mac__Sound_SPBOpenDevice, file);
        newXS("Mac::Sound::SPBCloseDevice", XS_Mac__Sound_SPBCloseDevice, file);
        newXS("Mac::Sound::SPBRecord", XS_Mac__Sound_SPBRecord, file);
#if XSubPPtmpAAAE
        newXS("Mac::Sound::SPBRecordToFile", XS_Mac__Sound_SPBRecordToFile, file);
#endif
#if XSubPPtmpAAAF
        newXS("Mac::Sound::SPBRecordToFile", XS_Mac__Sound_SPBRecordToFile, file);
#endif
        newXS("Mac::Sound::SPBPauseRecording", XS_Mac__Sound_SPBPauseRecording, file);
        newXS("Mac::Sound::SPBResumeRecording", XS_Mac__Sound_SPBResumeRecording, file);
        newXS("Mac::Sound::SPBStopRecording", XS_Mac__Sound_SPBStopRecording, file);
        newXS("Mac::Sound::SPBGetRecordingStatus", XS_Mac__Sound_SPBGetRecordingStatus, file);
        newXS("Mac::Sound::SPBMillisecondsToBytes", XS_Mac__Sound_SPBMillisecondsToBytes, file);
        newXS("Mac::Sound::SPBBytesToMilliseconds", XS_Mac__Sound_SPBBytesToMilliseconds, file);
        newXS("Mac::Sound::SetupSndHeader", XS_Mac__Sound_SetupSndHeader, file);
        newXS("Mac::Sound::SetupAIFFHeader", XS_Mac__Sound_SetupAIFFHeader, file);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#line 2181 "Sound.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

