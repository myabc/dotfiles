/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Processes.xs. Do not edit this file, edit Processes.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Processes.xs"
/* $Header: /cvsroot/macperl/perl/macos/ext/Mac/Processes/Processes.xs,v 1.10 2006/06/20 01:39:18 pudge Exp $
 *
 *    Copyright (c) 1996 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: Processes.xs,v $
 * Revision 1.10  2006/06/20 01:39:18  pudge
 * Loads of fixes, mostly for Intel port
 *
 * Revision 1.9  2003/10/28 05:53:30  pudge
 * Add Carbon compat. notes
 *
 * Revision 1.8  2003/04/06 21:34:08  pudge
 * Add LSFindApplicationForInfo to Mac::Processes for finding
 * applications on Mac OS X (by creator, bundle ID, or name)
 *
 * Revision 1.7  2002/12/12 14:58:07  pudge
 * Update POD and docs
 *
 * Revision 1.6  2002/12/10 01:50:57  pudge
 * Add GetProcessPID and GetProcessForPID, for mapping between Mac OS PSN
 * and Unix PID.
 *
 * Revision 1.5  2002/11/13 02:04:52  pudge
 * Aieeeeee!  Big ol' Carbon update.
 *
 * Revision 1.4  2002/01/23 05:44:42  pudge
 * Update whitespace etc., from Thomas
 *
 * Revision 1.3  2000/09/12 19:42:21  pudge
 * Make LaunchApplication return PSN on success, undef on failure
 *
 * Revision 1.2  2000/09/09 22:18:28  neeri
 * Dynamic libraries compile under 5.6
 *
 * Revision 1.1  2000/08/14 03:39:32  neeri
 * Checked into Sourceforge
 *
 * Revision 1.2  1997/11/18 00:53:10  neeri
 * MacPerl 5.1.5
 *
 * Revision 1.1  1997/04/07 20:50:30  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#endif
#include <Types.h>
#include <Memory.h>
#include <Processes.h>
#ifdef MACOS_TRADITIONAL
#include <GUSIFileSpec.h>
#endif

typedef LaunchPBPtr			LaunchParam;
typedef ProcessInfoRecPtr	ProcessInfo;

static ProcessInfo NewProcessInfo()
{
	ProcessInfo	pi;
	pi = (ProcessInfo) malloc(sizeof(ProcessInfoRec)+sizeof(FSSpec)+36);
	pi->processInfoLength	=	sizeof(ProcessInfoRec);
	pi->processName			=	(StringPtr)((char *)pi+sizeof(ProcessInfoRec));
	pi->processAppSpec		=	(FSSpecPtr)((char *)pi+sizeof(ProcessInfoRec)+36);
	
	return pi;
}

#line 88 "Processes.c"
XS(XS_LaunchParam_LaunchParam)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LaunchParam STRUCT;

#line 98 "Processes.xs"
	 STRUCT;

	if (sv_derived_from( ST(0), "LaunchParam")) {
	    IV tmp = SvIV((SV*)SvRV( ST(0)));
	     STRUCT = INT2PTR(LaunchParam,tmp);
	}
	else
	    Perl_croak(aTHX_ " STRUCT is not of type LaunchParam");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* launchFileFlags */
#line 99 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->launchFileFlags));
		break;
	    case 1:	  /* launchControlFlags */
#line 100 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->launchControlFlags));
		break;
	    case 2:	  /* launchAppSpec */
#line 101 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	MP_GUSIFSp2FullPath((STRUCT->launchAppSpec), *sp);
		break;
	    case 3:	  /* launchProcessSN */
#line 102 "Processes.xs"
	++sp;
	*sp = newSVnv((STRUCT->launchProcessSN).highLongOfPSN * 4294967296.0 + (STRUCT->launchProcessSN).lowLongOfPSN);	
	sv_2mortal(*sp);
		break;
	    case 4:	  /* launchPreferredSize */
#line 103 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->launchPreferredSize));
		break;
	    case 5:	  /* launchMinimumSize */
#line 104 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->launchMinimumSize));
		break;
	    case 6:	  /* launchAvailableSize */
#line 105 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->launchAvailableSize));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* launchFileFlags */
#line 99 "Processes.xs"
	 STRUCT->launchFileFlags = (unsigned short)SvUV( ST(1));
		break;
	    case 1:	  /* launchControlFlags */
#line 100 "Processes.xs"
	 STRUCT->launchControlFlags = (unsigned short)SvUV( ST(1));
		break;
	    case 2:	  /* launchAppSpec */
#line 101 "Processes.xs"
	 STRUCT->launchAppSpec;

	GUSIPath2FSp((char *) SvPV_nolen( ST(1)),  STRUCT->launchAppSpec);
		break;
	    case 3:	  /* launchProcessSN */
#line 102 "Processes.xs"
	 STRUCT->launchProcessSN;

	{
		double psn = SvNV( ST(1));
		double low = fmod(psn, 4294967296.0);

		 STRUCT->launchProcessSN.lowLongOfPSN = (long) low;
		 STRUCT->launchProcessSN.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
		break;
	    case 4:	  /* launchPreferredSize */
#line 103 "Processes.xs"
	 STRUCT->launchPreferredSize = (unsigned long)SvUV( ST(1));
		break;
	    case 5:	  /* launchMinimumSize */
#line 104 "Processes.xs"
	 STRUCT->launchMinimumSize = (unsigned long)SvUV( ST(1));
		break;
	    case 6:	  /* launchAvailableSize */
#line 105 "Processes.xs"
	 STRUCT->launchAvailableSize = (unsigned long)SvUV( ST(1));
		break;
	    }
#line 98 "Processes.xs"
	}
    }
    XSRETURN(1);
}

XS(XS_LaunchParam__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_LaunchParam__new)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: LaunchParam::_new()");
    {
	LaunchParam	RETVAL;
#line 118 "Processes.xs"
	RETVAL = (LaunchParam) malloc(sizeof(LaunchParamBlockRec)+sizeof(FSSpec));
	RETVAL->launchBlockID			=	extendedBlock;
	RETVAL->launchEPBLength			=	extendedBlockLen;
	RETVAL->launchAppSpec			=	(FSSpecPtr)((char *)RETVAL+sizeof(LaunchParamBlockRec));
	RETVAL->launchAppParameters	=	nil;
#line 214 "Processes.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "LaunchParam", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_LaunchParam_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_LaunchParam_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: LaunchParam::DESTROY(lpb)");
    {
	LaunchParam	lpb;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    lpb = INT2PTR(LaunchParam,tmp);
	}
	else
	    Perl_croak(aTHX_ "lpb is not a reference");
#line 135 "Processes.xs"
	free(lpb);
#line 238 "Processes.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_ProcessInfo_ProcessInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	ProcessInfo STRUCT;

#line 162 "Processes.xs"
	 STRUCT;

	if (SvROK( ST(0))) {
	    IV tmp = SvIV((SV*)SvRV( ST(0)));
	     STRUCT = INT2PTR(ProcessInfo,tmp);
	}
	else
	    Perl_croak(aTHX_ " STRUCT is not a reference");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* processName */
#line 163 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT->processName)) + 1, (STRUCT->processName)[0]);
		break;
	    case 1:	  /* processNumber */
#line 164 "Processes.xs"
	++sp;
	*sp = newSVnv((STRUCT->processNumber).highLongOfPSN * 4294967296.0 + (STRUCT->processNumber).lowLongOfPSN);	
	sv_2mortal(*sp);
		break;
	    case 2:	  /* processType */
#line 165 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->processType));
		break;
	    case 3:	  /* processSignature */
#line 166 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT->processSignature));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    case 4:	  /* processMode */
#line 167 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->processMode));
		break;
	    case 5:	  /* processLocation */
#line 168 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pv(*sp, "Ptr", (void*)(STRUCT->processLocation));
		break;
	    case 6:	  /* processSize */
#line 169 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->processSize));
		break;
	    case 7:	  /* processFreeMem */
#line 170 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->processFreeMem));
		break;
	    case 8:	  /* processLauncher */
#line 171 "Processes.xs"
	++sp;
	*sp = newSVnv((STRUCT->processLauncher).highLongOfPSN * 4294967296.0 + (STRUCT->processLauncher).lowLongOfPSN);	
	sv_2mortal(*sp);
		break;
	    case 9:	  /* processLaunchDate */
#line 172 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->processLaunchDate));
		break;
	    case 10:	  /* processActiveTime */
#line 173 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->processActiveTime));
		break;
	    case 11:	  /* processAppSpec */
#line 174 "Processes.xs"
	++sp;
	*sp = sv_newmortal();
	MP_GUSIFSp2FullPath((STRUCT->processAppSpec), *sp);
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* processName */
#line 163 "Processes.xs"
	 STRUCT->processName;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT->processName);
		break;
	    case 1:	  /* processNumber */
#line 164 "Processes.xs"
	 STRUCT->processNumber;

	{
		double psn = SvNV( ST(1));
		double low = fmod(psn, 4294967296.0);

		 STRUCT->processNumber.lowLongOfPSN = (long) low;
		 STRUCT->processNumber.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
		break;
	    case 2:	  /* processType */
#line 165 "Processes.xs"
	 STRUCT->processType = (unsigned long)SvUV( ST(1));
		break;
	    case 3:	  /* processSignature */
#line 166 "Processes.xs"
	 STRUCT->processSignature;

	memcpy(& STRUCT->processSignature, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT->processSignature = ntohl( STRUCT->processSignature);
		break;
	    case 4:	  /* processMode */
#line 167 "Processes.xs"
	 STRUCT->processMode = (unsigned long)SvUV( ST(1));
		break;
	    case 5:	  /* processLocation */
#line 168 "Processes.xs"
	 STRUCT->processLocation;

	if (SvROK( ST(1))) {
	    IV tmp = SvIV((SV*)SvRV( ST(1)));
	     STRUCT->processLocation = INT2PTR(Ptr,tmp);
	}
	else
	    Perl_croak(aTHX_ " STRUCT->processLocation is not a reference");
		break;
	    case 6:	  /* processSize */
#line 169 "Processes.xs"
	 STRUCT->processSize = (unsigned long)SvUV( ST(1));
		break;
	    case 7:	  /* processFreeMem */
#line 170 "Processes.xs"
	 STRUCT->processFreeMem = (unsigned long)SvUV( ST(1));
		break;
	    case 8:	  /* processLauncher */
#line 171 "Processes.xs"
	 STRUCT->processLauncher;

	{
		double psn = SvNV( ST(1));
		double low = fmod(psn, 4294967296.0);

		 STRUCT->processLauncher.lowLongOfPSN = (long) low;
		 STRUCT->processLauncher.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
		break;
	    case 9:	  /* processLaunchDate */
#line 172 "Processes.xs"
	 STRUCT->processLaunchDate = (unsigned long)SvUV( ST(1));
		break;
	    case 10:	  /* processActiveTime */
#line 173 "Processes.xs"
	 STRUCT->processActiveTime = (unsigned long)SvUV( ST(1));
		break;
	    case 11:	  /* processAppSpec */
#line 174 "Processes.xs"
	 STRUCT->processAppSpec;

	GUSIPath2FSp((char *) SvPV_nolen( ST(1)),  STRUCT->processAppSpec);
		break;
	    }
#line 162 "Processes.xs"
	}
    }
    XSRETURN(1);
}

XS(XS_ProcessInfo_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_ProcessInfo_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: ProcessInfo::DESTROY(pi)");
    {
	ProcessInfo	pi;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pi = INT2PTR(ProcessInfo,tmp);
	}
	else
	    Perl_croak(aTHX_ "pi is not a reference");
#line 185 "Processes.xs"
	free(pi);
#line 443 "Processes.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Mac__Processes_LaunchApplication); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_LaunchApplication)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::LaunchApplication(LaunchParams)");
    {
	LaunchParam	LaunchParams;
	ProcessSerialNumber	RETVAL;

	if (sv_derived_from(ST(0), "LaunchParam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    LaunchParams = INT2PTR(LaunchParam,tmp);
	}
	else
	    Perl_croak(aTHX_ "LaunchParams is not of type LaunchParam");
#line 204 "Processes.xs"
	if (gMacPerl_OSErr = LaunchApplication(LaunchParams)) {
        XSRETURN_UNDEF;
    }
	RETVAL = LaunchParams->launchProcessSN;
#line 469 "Processes.c"
	ST(0) = newSVnv(RETVAL.highLongOfPSN * 4294967296.0 + RETVAL.lowLongOfPSN);	
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_LaunchDeskAccessory); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_LaunchDeskAccessory)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Processes::LaunchDeskAccessory(pFileSpec, pDAName)");
    {
	SV *	pFileSpec = ST(0);
	Str255	pDAName;
#line 229 "Processes.xs"
	FSSpec	spec;
	FSSpec *	fssp = nil;
#line 488 "Processes.c"
	MacOSRet	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), pDAName);
#line 232 "Processes.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Processes::LaunchDeskAccessory unsupported in Carbon");
#else
	if (SvTRUE(pFileSpec) && GUSIPath2FSp(SvPV_nolen(pFileSpec), &spec))
		fssp = &spec;
	RETVAL = LaunchDeskAccessory(fssp, pDAName);
#endif
#line 501 "Processes.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_GetCurrentProcess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_GetCurrentProcess)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Processes::GetCurrentProcess()");
    {
	ProcessSerialNumber	RETVAL;
#line 253 "Processes.xs"
	if (gMacPerl_OSErr = GetCurrentProcess(&RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 519 "Processes.c"
	ST(0) = newSVnv(RETVAL.highLongOfPSN * 4294967296.0 + RETVAL.lowLongOfPSN);	
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_GetFrontProcess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_GetFrontProcess)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Processes::GetFrontProcess()");
    {
	ProcessSerialNumber	RETVAL;
#line 269 "Processes.xs"
	if (gMacPerl_OSErr = GetFrontProcess(&RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 538 "Processes.c"
	ST(0) = newSVnv(RETVAL.highLongOfPSN * 4294967296.0 + RETVAL.lowLongOfPSN);	
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_GetNextProcess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_GetNextProcess)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::GetNextProcess(PSN)");
    {
	ProcessSerialNumber	PSN;
	ProcessSerialNumber	RETVAL;

	{
		double psn = SvNV(ST(0));
		double low = fmod(psn, 4294967296.0);

		PSN.lowLongOfPSN = (long) low;
		PSN.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
#line 286 "Processes.xs"
	if (gMacPerl_OSErr = GetNextProcess(&PSN)) {
		XSRETURN_UNDEF;
	} else
		RETVAL = PSN;
#line 567 "Processes.c"
	ST(0) = newSVnv(RETVAL.highLongOfPSN * 4294967296.0 + RETVAL.lowLongOfPSN);	
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_GetProcessInformation); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_GetProcessInformation)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::GetProcessInformation(PSN)");
    {
	ProcessSerialNumber	PSN;
	ProcessInfo	RETVAL;

	{
		double psn = SvNV(ST(0));
		double low = fmod(psn, 4294967296.0);

		PSN.lowLongOfPSN = (long) low;
		PSN.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
#line 310 "Processes.xs"
	RETVAL = NewProcessInfo();
	if (gMacPerl_OSErr = GetProcessInformation(&PSN, RETVAL)) {
		free(RETVAL);
		XSRETURN_UNDEF;
	} 
#line 597 "Processes.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ProcessInfo", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_SetFrontProcess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_SetFrontProcess)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::SetFrontProcess(PSN)");
    {
	ProcessSerialNumber	PSN;
	MacOSRet	RETVAL;
	dXSTARG;

	{
		double psn = SvNV(ST(0));
		double low = fmod(psn, 4294967296.0);

		PSN.lowLongOfPSN = (long) low;
		PSN.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};

	RETVAL = SetFrontProcess(&PSN);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_WakeUpProcess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_WakeUpProcess)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::WakeUpProcess(PSN)");
    {
	ProcessSerialNumber	PSN;
	MacOSRet	RETVAL;
	dXSTARG;

	{
		double psn = SvNV(ST(0));
		double low = fmod(psn, 4294967296.0);

		PSN.lowLongOfPSN = (long) low;
		PSN.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};

	RETVAL = WakeUpProcess(&PSN);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_SameProcess); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_SameProcess)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Processes::SameProcess(PSN1, PSN2)");
    {
	ProcessSerialNumber	PSN1;
	ProcessSerialNumber	PSN2;
	Boolean	RETVAL;

	{
		double psn = SvNV(ST(0));
		double low = fmod(psn, 4294967296.0);

		PSN1.lowLongOfPSN = (long) low;
		PSN1.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};

	{
		double psn = SvNV(ST(1));
		double low = fmod(psn, 4294967296.0);

		PSN2.lowLongOfPSN = (long) low;
		PSN2.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
#line 358 "Processes.xs"
	if (gMacPerl_OSErr = SameProcess(&PSN1, &PSN2, &RETVAL)) {
		XSRETURN_UNDEF;
	} 
#line 684 "Processes.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_ExitToShell); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_ExitToShell)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Processes::ExitToShell()");
    {
#line 372 "Processes.xs"
	croak("ExitToShell() unsupported. Use exit.");
#line 700 "Processes.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Mac__Processes_GetProcessPID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_GetProcessPID)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::GetProcessPID(PSN)");
    {
	ProcessSerialNumber	PSN;
	pid_t	RETVAL;
	dXSTARG;

	{
		double psn = SvNV(ST(0));
		double low = fmod(psn, 4294967296.0);

		PSN.lowLongOfPSN = (long) low;
		PSN.highLongOfPSN = (long) ((psn - low)/4294967296.0);
	};
#line 385 "Processes.xs"
#ifdef MACOS_TRADITIONAL
	croak("Usage: Mac::Processes::GetProcessPID unsupported in Mac OS");
#else
	if (gMacPerl_OSErr = GetProcessPID(&PSN, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#endif
#line 731 "Processes.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_GetProcessForPID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_GetProcessForPID)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Processes::GetProcessForPID(PID)");
    {
	pid_t	PID = (pid_t)SvIV(ST(0));
	ProcessSerialNumber	RETVAL;
#line 406 "Processes.xs"
#ifdef MACOS_TRADITIONAL
	croak("Usage: Mac::Processes::GetProcessForPID unsupported in Mac OS");
#else
	if (gMacPerl_OSErr = GetProcessForPID(PID, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#endif
#line 754 "Processes.c"
	ST(0) = newSVnv(RETVAL.highLongOfPSN * 4294967296.0 + RETVAL.lowLongOfPSN);	
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Processes_LSFindApplicationForInfo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Processes_LSFindApplicationForInfo)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Processes::LSFindApplicationForInfo(creator, bundleID=NULL, name=NULL)");
    {
	OSType	creator;
	CFStringRef	bundleID;
	CFStringRef	name;
	FSRef	RETVAL;

	memcpy(&creator, SvPV_nolen(ST(0)), sizeof(OSType));
	creator = ntohl(creator);

	if (items < 2)
	    bundleID = NULL;
	else {
	    bundleID = CFStringCreateWithCString(NULL, (char *) SvPV_nolen(ST(1)), kCFStringEncodingISOLatin1);
	}

	if (items < 3)
	    name = NULL;
	else {
	    name = CFStringCreateWithCString(NULL, (char *) SvPV_nolen(ST(2)), kCFStringEncodingISOLatin1);
	}
#line 435 "Processes.xs"
	if (strlen(SvPV_nolen(ST(0))) == 0)
		creator = NULL;
	if (bundleID != NULL && CFStringGetLength(bundleID) == 0)
		bundleID = NULL;
	if (name != NULL && CFStringGetLength(name) == 0)
		name = NULL;
#line 794 "Processes.c"
#line 442 "Processes.xs"
#ifdef MACOS_TRADITIONAL
	croak("Usage: Mac::Processes::LSFindApplicationForInfo unsupported in Mac OS");
#else
	if (gMacPerl_OSErr = LSFindApplicationForInfo(creator, bundleID, name, &RETVAL, NULL)) {
		XSRETURN_UNDEF;
	}
#endif
#line 803 "Processes.c"
	ST(0) = sv_newmortal();
	MP_GUSIFS2FullPath(&RETVAL, ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__Processes); /* prototype to pass -Wmissing-prototypes */
XS(boot_Mac__Processes)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        cv = newXS("LaunchParam::launchFileFlags", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("LaunchParam::launchControlFlags", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("LaunchParam::launchAppSpec", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("LaunchParam::launchProcessSN", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("LaunchParam::launchPreferredSize", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("LaunchParam::launchMinimumSize", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("LaunchParam::launchAvailableSize", XS_LaunchParam_LaunchParam, file);
        XSANY.any_i32 = 6 ; 
        newXS("LaunchParam::_new", XS_LaunchParam__new, file);
        newXS("LaunchParam::DESTROY", XS_LaunchParam_DESTROY, file);
        cv = newXS("ProcessInfo::processName", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("ProcessInfo::processNumber", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("ProcessInfo::processType", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("ProcessInfo::processSignature", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("ProcessInfo::processMode", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("ProcessInfo::processLocation", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("ProcessInfo::processSize", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 6 ; 
        cv = newXS("ProcessInfo::processFreeMem", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 7 ; 
        cv = newXS("ProcessInfo::processLauncher", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 8 ; 
        cv = newXS("ProcessInfo::processLaunchDate", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 9 ; 
        cv = newXS("ProcessInfo::processActiveTime", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 10 ; 
        cv = newXS("ProcessInfo::processAppSpec", XS_ProcessInfo_ProcessInfo, file);
        XSANY.any_i32 = 11 ; 
        newXS("ProcessInfo::DESTROY", XS_ProcessInfo_DESTROY, file);
        newXS("Mac::Processes::LaunchApplication", XS_Mac__Processes_LaunchApplication, file);
        newXS("Mac::Processes::LaunchDeskAccessory", XS_Mac__Processes_LaunchDeskAccessory, file);
        newXS("Mac::Processes::GetCurrentProcess", XS_Mac__Processes_GetCurrentProcess, file);
        newXS("Mac::Processes::GetFrontProcess", XS_Mac__Processes_GetFrontProcess, file);
        newXS("Mac::Processes::GetNextProcess", XS_Mac__Processes_GetNextProcess, file);
        newXS("Mac::Processes::GetProcessInformation", XS_Mac__Processes_GetProcessInformation, file);
        newXS("Mac::Processes::SetFrontProcess", XS_Mac__Processes_SetFrontProcess, file);
        newXS("Mac::Processes::WakeUpProcess", XS_Mac__Processes_WakeUpProcess, file);
        newXS("Mac::Processes::SameProcess", XS_Mac__Processes_SameProcess, file);
        newXS("Mac::Processes::ExitToShell", XS_Mac__Processes_ExitToShell, file);
        newXS("Mac::Processes::GetProcessPID", XS_Mac__Processes_GetProcessPID, file);
        newXS("Mac::Processes::GetProcessForPID", XS_Mac__Processes_GetProcessForPID, file);
        newXS("Mac::Processes::LSFindApplicationForInfo", XS_Mac__Processes_LSFindApplicationForInfo, file);
    XSRETURN_YES;
}

