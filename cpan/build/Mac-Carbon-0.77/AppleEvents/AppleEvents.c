/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of AppleEvents.xs. Do not edit this file, edit AppleEvents.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "AppleEvents.xs"
/* $Header: /cvsroot/macperl/perl/macos/ext/Mac/AppleEvents/AppleEvents.xs,v 1.12 2006/06/20 01:39:17 pudge Exp $
 *
 *    Copyright (c) 1996 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: AppleEvents.xs,v $
 * Revision 1.12  2006/06/20 01:39:17  pudge
 * Loads of fixes, mostly for Intel port
 *
 * Revision 1.11  2004/05/11 05:36:18  pudge
 * oops
 *
 * Revision 1.10  2004/05/11 05:28:26  pudge
 * Eliminate a number of memory leaks due to lack of disposal of Handles,
 * due to changes for Mac OS X.
 *
 * Revision 1.9  2003/10/28 05:53:58  pudge
 * Add Carbon compat. notes; revert to AESend for AESend instead of AESendMessage
 *
 * Revision 1.8  2003/04/06 21:16:51  pudge
 * Fix segfault for NULL descriptor in new AEDesc
 *
 * Revision 1.7  2002/12/17 16:16:07  pudge
 * Use new constant
 *
 * Revision 1.6  2002/12/12 15:36:33  pudge
 * Make work with gcc2
 *
 * Revision 1.5  2002/12/12 14:57:16  pudge
 * Update POD and docs
 *
 * Revision 1.4  2002/12/10 19:13:22  pudge
 * Fix dumb bug in getting AEDesc data.  Remove debugging code.
 *
 * Revision 1.3  2002/12/10 03:06:23  pudge
 * Big update for Carbon support
 *
 * Revision 1.2  2000/09/09 22:18:25  neeri
 * Dynamic libraries compile under 5.6
 *
 * Revision 1.1  2000/08/14 01:48:18  neeri
 * Checked into Sourceforge
 *
 * Revision 1.3  1999/06/03 19:22:05  pudge
 * Add AEPutKey, AEPutKeyDesc, AEGetKeyDesc functions.  Inline constant subroutines.
 *
 * Revision 1.2  1997/11/18 00:52:07  neeri
 * MacPerl 5.1.5
 *
 * Revision 1.1  1997/04/07 20:49:07  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#include "CarbonAE.h"
#endif
#include <stdarg.h>
#include <Types.h>
#include <Memory.h>
#include <AppleEvents.h>
#include "PerlAEUtils.h"
#ifdef MACOS_TRADITIONAL
#include "SubLaunch.h"
#endif

typedef int 	SysRet;
typedef long	SysRetLong;

#define AEFail(error)	if (gMacPerl_OSErr = (error)) { XSRETURN_UNDEF; } else 0

#line 90 "AppleEvents.c"
XS(XS_AEDesc__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEDesc__new)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: AEDesc::_new(package, type='null', data=0)");
    {
	SV *	package = ST(0);
	OSType	type;
	Handle	data;
	AEDesc	RETVAL;

	if (items < 2)
	    type = 'null';
	else {
	    memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	    type = ntohl(type);
	}

	if (items < 3)
	    data = 0;
	else {
	    if (sv_derived_from(ST(2), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		data = INT2PTR(Handle,tmp);
	    }
	    else
		Perl_croak(aTHX_ "data is not of type Handle");
	}
#line 88 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
		RETVAL.descriptorType	=	type;
		RETVAL.dataHandle			=	data;
#else
		if (data == NULL) {
			AEFail(AECreateDesc(type, NULL, 0, &RETVAL));
		} else {
			ConvertFourCharCode(type, *data);
			AEFail(AECreateDesc(type, *data, GetHandleSize(data), &RETVAL));
			DisposeHandle(data);
		}
#endif
	}
#line 135 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_AEDesc_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEDesc_type)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEDesc::type(desc, newType=0)");
    {
	AEDesc	desc;
	OSType	newType;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");

	if (items < 2)
	    newType = 0;
	else {
	    memcpy(&newType, SvPV_nolen(ST(1)), sizeof(OSType));
	    newType = ntohl(newType);
	}
#line 110 "AppleEvents.xs"
	{
		if (items > 1)
			desc.descriptorType	=	newType;
		RETVAL = desc.descriptorType;
	}
#line 170 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEDesc", (void*)&desc, sizeof(AEDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	{ OSType hos = htonl(RETVAL);
	  sv_setpvn(ST(0), (char *) &hos, 4);
	}
    }
    XSRETURN(1);
}

XS(XS_AEDesc_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEDesc_data)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEDesc::data(desc, newData=0)");
    {
	AEDesc	desc;
	Handle	newData;
	Handle	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");

	if (items < 2)
	    newData = 0;
	else {
	    if (sv_derived_from(ST(1), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		newData = INT2PTR(Handle,tmp);
	    }
	    else
		Perl_croak(aTHX_ "newData is not of type Handle");
	}
#line 124 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
		if (items > 1) {
			DisposeHandle(desc.dataHandle);
			desc.dataHandle	=	newData;
		}
		RETVAL = desc.dataHandle;
#else
		Size descLen;

		if (items>1) {
			ConvertFourCharCode(desc.descriptorType, *newData);
			AEReplaceDescData(desc.descriptorType, *newData,
				GetHandleSize(newData), &desc);
			DisposeHandle(newData);
		}

		descLen = AEGetDescDataSize(&desc);
		RETVAL = NewHandle(descLen);
		AEFail(AEGetDescData(&desc, *RETVAL, descLen));
		ConvertFourCharCode(desc.descriptorType, *RETVAL);
#endif
	}
#line 231 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEDesc", (void*)&desc, sizeof(AEDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEKeyDesc__new)
{
    dXSARGS;
    if (items < 1 || items > 4)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::_new(package, key=0, type='null', data=0)");
    {
	SV *	package = ST(0);
	OSType	key;
	OSType	type;
	Handle	data;
	AEKeyDesc	RETVAL;

	if (items < 2)
	    key = 0;
	else {
	    memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
	    key = ntohl(key);
	}

	if (items < 3)
	    type = 'null';
	else {
	    memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));
	    type = ntohl(type);
	}

	if (items < 4)
	    data = 0;
	else {
	    if (sv_derived_from(ST(3), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(3)));
		data = INT2PTR(Handle,tmp);
	    }
	    else
		Perl_croak(aTHX_ "data is not of type Handle");
	}
#line 160 "AppleEvents.xs"
	{
		RETVAL.descKey								=	key;
#ifdef MACOS_TRADITIONAL
		RETVAL.descContent.descriptorType	=	type;
		RETVAL.descContent.dataHandle			=	data;
#else
		if (data == NULL) {
			AEFail(AECreateDesc(type, NULL, 0, &RETVAL.descContent));
		} else {
			ConvertFourCharCode(type, *data);
			AEFail(AECreateDesc(type, *data, GetHandleSize(data), &RETVAL.descContent));
			DisposeHandle(data);
		}
#endif
	}
#line 293 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&RETVAL, sizeof(AEKeyDesc));
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEKeyDesc_key)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::key(desc, newKey=0)");
    {
	AEKeyDesc	desc;
	OSType	newKey;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");

	if (items < 2)
	    newKey = 0;
	else {
	    memcpy(&newKey, SvPV_nolen(ST(1)), sizeof(OSType));
	    newKey = ntohl(newKey);
	}
#line 183 "AppleEvents.xs"
	{
		if (items>1)
			desc.descKey	=	newKey;
		RETVAL = desc.descKey;
	}
#line 328 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	{ OSType hos = htonl(RETVAL);
	  sv_setpvn(ST(0), (char *) &hos, 4);
	}
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEKeyDesc_type)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::type(desc, newType=0)");
    {
	AEKeyDesc	desc;
	OSType	newType;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");

	if (items < 2)
	    newType = 0;
	else {
	    memcpy(&newType, SvPV_nolen(ST(1)), sizeof(OSType));
	    newType = ntohl(newType);
	}
#line 197 "AppleEvents.xs"
	{
		if (items>1)
			desc.descContent.descriptorType	=	newType;
		RETVAL = desc.descContent.descriptorType;
	}
#line 367 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	{ OSType hos = htonl(RETVAL);
	  sv_setpvn(ST(0), (char *) &hos, 4);
	}
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEKeyDesc_data)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::data(desc, newData=0)");
    {
	AEKeyDesc	desc;
	Handle	newData;
	Handle	RETVAL;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");

	if (items < 2)
	    newData = 0;
	else {
	    if (sv_derived_from(ST(1), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		newData = INT2PTR(Handle,tmp);
	    }
	    else
		Perl_croak(aTHX_ "newData is not of type Handle");
	}
#line 211 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
		if (items>1)
			desc.descContent.dataHandle	=	newData;
		RETVAL = desc.descContent.dataHandle;
#else
		Size descLen;

		if (items>1) {
			ConvertFourCharCode(desc.descContent.descriptorType, *newData);
			AEReplaceDescData(desc.descContent.descriptorType, *newData,
				GetHandleSize(newData), &desc.descContent);
		}

		descLen = AEGetDescDataSize(&desc.descContent);
		RETVAL = NewHandle(descLen);
		AEFail(AEGetDescData(&desc.descContent, *RETVAL, descLen));
		ConvertFourCharCode(desc.descContent.descriptorType, *RETVAL);
#endif
	}
#line 425 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_desc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEKeyDesc_desc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::desc(desc)");
    {
	AEKeyDesc	desc;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");
#line 239 "AppleEvents.xs"
	{
		RETVAL = desc.descContent;
	}
#line 452 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECreateDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECreateDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECreateDesc(typeCode, data)");
    {
	OSType	typeCode;
	SV *	data = ST(1);
	AEDesc	RETVAL;

	memcpy(&typeCode, SvPV_nolen(ST(0)), sizeof(OSType));
	typeCode = ntohl(typeCode);
#line 263 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;
		OSErr		error;

		dataPtr = SvPV(data, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);

		error = AECreateDesc(typeCode, dataPtr, dataSize, &RETVAL);
		ConvertFourCharCode(typeCode, dataPtr);
		AEFail(error);
	}
#line 487 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECoerce); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECoerce)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECoerce(typeCode, data, toType)");
    {
	OSType	typeCode;
	SV *	data = ST(1);
	OSType	toType;
	AEDesc	RETVAL;

	memcpy(&typeCode, SvPV_nolen(ST(0)), sizeof(OSType));
	typeCode = ntohl(typeCode);

	memcpy(&toType, SvPV_nolen(ST(2)), sizeof(OSType));
	toType = ntohl(toType);
#line 292 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;
		OSErr		error;

		dataPtr = SvPV(data, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);

		error = AECoercePtr(typeCode, dataPtr, dataSize, toType, &RETVAL);
		ConvertFourCharCode(typeCode, dataPtr);
		AEFail(error);
	}
#line 524 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECoerceDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECoerceDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECoerceDesc(theAEDesc, toType)");
    {
	AEDesc	theAEDesc;
	OSType	toType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	memcpy(&toType, SvPV_nolen(ST(1)), sizeof(OSType));
	toType = ntohl(toType);
#line 312 "AppleEvents.xs"
	AEFail(AECoerceDesc(&theAEDesc, toType, &RETVAL));
#line 551 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDisposeDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEDisposeDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDisposeDesc(theAEDesc)");
    {
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEDisposeDesc(&theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDuplicateDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEDuplicateDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDuplicateDesc(theAEDesc)");
    {
	AEDesc	theAEDesc;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");
#line 344 "AppleEvents.xs"
	AEFail(AEDuplicateDesc(&theAEDesc, &RETVAL));
#line 596 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECreateList); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECreateList)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECreateList(factoring, isRecord)");
    {
	SV *	factoring = ST(0);
	Boolean	isRecord = (bool)SvTRUE(ST(1));
	AEDesc	RETVAL;
#line 365 "AppleEvents.xs"
	{
		void *	factoringPtr;
		STRLEN	factoredSize;

		factoringPtr 	= 	SvPV(factoring, factoredSize);
		AEFail(AECreateList(factoringPtr, factoredSize, isRecord, &RETVAL));
	}
#line 621 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECountItems); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECountItems)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECountItems(theAEDescList)");
    {
	AEDesc	theAEDescList;
	SysRetLong	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");
#line 385 "AppleEvents.xs"
	AEFail(AECountItems(&theAEDescList, &RETVAL));
#line 644 "AppleEvents.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPut); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPut)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPut(theAEDescList, index, typeCode, data)");
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
	typeCode = ntohl(typeCode);
#line 405 "AppleEvents.xs"
	{
		char *	dataPtr;
		STRLEN	dataSize;

		dataPtr 	= 	SvPV(data, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);

		RETVAL	=	AEPutPtr(&theAEDescList, index, typeCode, dataPtr, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);
	}
#line 688 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutDesc(theAEDescList, index, theAEDesc)");
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutDesc(&theAEDescList, index, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutKey)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutKey(theAERecord, theAEKeyword, typeCode, data)");
    {
	AEDesc	theAERecord;
	OSType	theAEKeyword;
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAERecord, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAERecord is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
	typeCode = ntohl(typeCode);
#line 441 "AppleEvents.xs"
	{
		char *	dataPtr;
		STRLEN	dataSize;

		dataPtr		=	SvPV(data, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);

		RETVAL	=	AEPutKeyPtr(&theAERecord, theAEKeyword, typeCode, dataPtr, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);
	}
#line 758 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutKeyDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutKeyDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutKeyDesc(theAERecord, theAEKeyword, theAEDesc)");
    {
	AEDesc	theAERecord;
	OSType	theAEKeyword;
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAERecord, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAERecord is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutKeyDesc(&theAERecord, theAEKeyword, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetNthDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetNthDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetNthDesc(theAEDescList, index, desiredType=typeWildCard)");
    SP -= items;
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	OSType	desiredType;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	    desiredType = ntohl(desiredType);
	}
#line 479 "AppleEvents.xs"
	{
		OSType 	kw;
		AEDesc	desc;

		AEFail(AEGetNthDesc(&theAEDescList, index, desiredType, &kw, &desc));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "AEDesc", (void*)&(desc), sizeof(AEDesc));
		if (GIMME == G_ARRAY && kw != typeWildCard) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((kw));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		}
	}
#line 838 "AppleEvents.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__AppleEvents_AEGetKeyDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetKeyDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetKeyDesc(theAEDescList, theAEKeyword, desiredType=typeWildCard)");
    {
	AEDesc	theAEDescList;
	OSType	theAEKeyword;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	    desiredType = ntohl(desiredType);
	}
#line 502 "AppleEvents.xs"
	AEFail(AEGetKeyDesc(&theAEDescList, theAEKeyword, desiredType, &RETVAL));
#line 872 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDeleteItem); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEDeleteItem)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDeleteItem(theAEDescList, index)");
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	RETVAL = AEDeleteItem(&theAEDescList, index);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutParam); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutParam)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutParam(theAppleEvent, theAEKeyword, typeCode, data)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
	typeCode = ntohl(typeCode);
#line 532 "AppleEvents.xs"
	{
		char *	dataPtr;
		STRLEN	dataSize;

		dataPtr 	= 	SvPV(data, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);

		RETVAL	=	AEPutParamPtr(&theAppleEvent, theAEKeyword, typeCode, dataPtr, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);
	}
#line 937 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutParamDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutParamDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutParamDesc(theAppleEvent, theAEKeyword, theAEDesc)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutParamDesc(&theAppleEvent, theAEKeyword, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetParamDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetParamDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetParamDesc(theAppleEvent, theAEKeyword, desiredType=typeWildCard)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	    desiredType = ntohl(desiredType);
	}
#line 564 "AppleEvents.xs"
	AEFail(AEGetParamDesc(&theAppleEvent, theAEKeyword, desiredType, &RETVAL));
#line 1003 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDeleteParam); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEDeleteParam)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDeleteParam(theAppleEvent, theAEKeyword)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	RETVAL = AEDeleteParam(&theAppleEvent, theAEKeyword);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetAttributeDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetAttributeDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetAttributeDesc(theAppleEvent, theAEKeyword, desiredType=typeWildCard)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	    desiredType = ntohl(desiredType);
	}
#line 591 "AppleEvents.xs"
	AEFail(AEGetAttributeDesc(&theAppleEvent, theAEKeyword, desiredType, &RETVAL));
#line 1064 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutAttribute); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutAttribute)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutAttribute(theAppleEvent, theAEKeyword, typeCode, data)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
	typeCode = ntohl(typeCode);
#line 612 "AppleEvents.xs"
	{
		char *	dataPtr;
		STRLEN	dataSize;

		dataPtr 	= 	SvPV(data, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);

		RETVAL	=	AEPutAttributePtr(&theAppleEvent, theAEKeyword, typeCode, dataPtr, dataSize);
		ConvertFourCharCode(typeCode, dataPtr);
	}
#line 1106 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutAttributeDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPutAttributeDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutAttributeDesc(theAppleEvent, theAEKeyword, theAEDesc)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEKeyword = ntohl(theAEKeyword);

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutAttributeDesc(&theAppleEvent, theAEKeyword, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECreateAppleEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECreateAppleEvent)
{
    dXSARGS;
    if (items < 3 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECreateAppleEvent(theAEEventClass, theAEEventID, target, returnID=kAutoGenerateReturnID, transactionID=0)");
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	AEDesc	target;
	short	returnID;
	long	transactionID;
	AEDesc	RETVAL;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));
	theAEEventClass = ntohl(theAEEventClass);

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEEventID = ntohl(theAEEventID);

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&target, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("target is not of type AEDesc");

	if (items < 4)
	    returnID = kAutoGenerateReturnID;
	else {
	    returnID = (short)SvIV(ST(3));
	}

	if (items < 5)
	    transactionID = 0;
	else {
	    transactionID = (long)SvIV(ST(4));
	}
#line 646 "AppleEvents.xs"
	if (gPAECreate)
		AEFail(
			CallOSACreateAppleEventProc(gPAECreate,
				theAEEventClass, theAEEventID, 
				&target, returnID, transactionID, &RETVAL, 
				gPAECreateRefCon));
	else
		AEFail(
			AECreateAppleEvent(
				theAEEventClass, theAEEventID, 
				&target, returnID, transactionID, &RETVAL));
#line 1192 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESend)
{
    dXSARGS;
    if (items < 2 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESend(theAppleEvent, sendMode, sendPriority=kAENormalPriority, timeout=kAEDefaultTimeout)");
    {
	AEDesc	theAppleEvent;
	long	sendMode = (long)SvIV(ST(1));
	short	sendPriority;
	long	timeout;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	if (items < 3)
	    sendPriority = kAENormalPriority;
	else {
	    sendPriority = (short)SvIV(ST(2));
	}

	if (items < 4)
	    timeout = kAEDefaultTimeout;
	else {
	    timeout = (long)SvIV(ST(3));
	}
#line 675 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
	if (gPAESend) 
		AEFail(
			CallOSASendProc(gPAESend,
				&theAppleEvent, &RETVAL, 
				sendMode, sendPriority, timeout, (AEIdleUPP) &uSubLaunchIdle, nil,
				gPAESendRefCon));
	else
		AEFail(
			AESend(
				&theAppleEvent, &RETVAL, 
				sendMode, sendPriority, timeout, (AEIdleUPP) &uSubLaunchIdle, nil));
#else
	// Mac OS X version doesn't use an idle proc
	AEFail(
		AESend(
			&theAppleEvent, &RETVAL, 
			sendMode, sendPriority, timeout, nil, nil));
#endif
	}
#line 1250 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEResetTimer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEResetTimer)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEResetTimer(reply)");
    {
	AEDesc	reply;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&reply, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("reply is not of type AEDesc");

	RETVAL = AEResetTimer(&reply);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESuspendTheCurrentEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESuspendTheCurrentEvent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESuspendTheCurrentEvent(theAppleEvent)");
    {
	AEDesc	theAppleEvent;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	RETVAL = AESuspendTheCurrentEvent(&theAppleEvent);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEResumeTheCurrentEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEResumeTheCurrentEvent)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEResumeTheCurrentEvent(theAppleEvent, flags=kAENoDispatch, handlerRefcon=0)");
    {
	AEDesc	theAppleEvent;
	long	flags;
	long	handlerRefcon;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	if (items < 2)
	    flags = kAENoDispatch;
	else {
	    flags = (long)SvIV(ST(1));
	}

	if (items < 3)
	    handlerRefcon = 0;
	else {
	    handlerRefcon = (long)SvIV(ST(2));
	}
#line 739 "AppleEvents.xs"
	AEFail(
		AEResumeTheCurrentEvent(
			&theAppleEvent, &RETVAL, (AEEventHandlerUPP) flags, handlerRefcon));
#line 1333 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetTheCurrentEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetTheCurrentEvent)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetTheCurrentEvent()");
    {
	AEDesc	RETVAL;
#line 753 "AppleEvents.xs"
	AEFail(AEGetTheCurrentEvent(&RETVAL));
#line 1350 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESetTheCurrentEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESetTheCurrentEvent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESetTheCurrentEvent(theAppleEvent)");
    {
	AEDesc	theAppleEvent;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	RETVAL = AESetTheCurrentEvent(&theAppleEvent);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetInteractionAllowed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetInteractionAllowed)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetInteractionAllowed()");
    {
	SysRet	RETVAL;
#line 777 "AppleEvents.xs"
	{
		char	level;

		AEFail(AEGetInteractionAllowed((AEInteractAllowed *)&level));
		RETVAL = level;
	}
#line 1394 "AppleEvents.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESetInteractionAllowed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESetInteractionAllowed)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESetInteractionAllowed(level)");
    {
	char	level = (char)*SvPV_nolen(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;
#line 796 "AppleEvents.xs"
	RETVAL = AESetInteractionAllowed((AEInteractAllowed)level);
#line 1418 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEInstallEventHandler); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEInstallEventHandler)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEInstallEventHandler(theAEEventClass, theAEEventID, handler, handlerRefcon, isSysHandler=0)");
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	SV *	handler = ST(2);
	SV *	handlerRefcon = ST(3);
	Boolean	isSysHandler;
	MacOSRet	RETVAL;
	dXSTARG;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));
	theAEEventClass = ntohl(theAEEventClass);

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEEventID = ntohl(theAEEventID);

	if (items < 5)
	    isSysHandler = 0;
	else {
	    isSysHandler = (bool)SvTRUE(ST(4));
	}
#line 830 "AppleEvents.xs"
	{
		RETVAL = PAEInstallEventHandler(theAEEventClass, theAEEventID, handler, handlerRefcon, isSysHandler);
	}
#line 1454 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AERemoveEventHandler); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AERemoveEventHandler)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AERemoveEventHandler(theAEEventClass, theAEEventID, isSysHandler=0)");
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	Boolean	isSysHandler;
	MacOSRet	RETVAL;
	dXSTARG;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));
	theAEEventClass = ntohl(theAEEventClass);

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEEventID = ntohl(theAEEventID);

	if (items < 3)
	    isSysHandler = 0;
	else {
	    isSysHandler = (bool)SvTRUE(ST(2));
	}
#line 848 "AppleEvents.xs"
	RETVAL = PAERemoveEventHandler(theAEEventClass, theAEEventID, isSysHandler);
#line 1486 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetEventHandler); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetEventHandler)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetEventHandler(theAEEventClass, theAEEventID, isSysHandler=0)");
    SP -= items;
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	Boolean	isSysHandler;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));
	theAEEventClass = ntohl(theAEEventClass);

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));
	theAEEventID = ntohl(theAEEventID);

	if (items < 3)
	    isSysHandler = 0;
	else {
	    isSysHandler = (bool)SvTRUE(ST(2));
	}
#line 866 "AppleEvents.xs"
	{
		SV * handler = sv_newmortal();
		SV * refCon  = sv_newmortal();

		AEFail(
			PAEGetEventHandler(
				theAEEventClass, theAEEventID, handler, refCon, isSysHandler));
		XPUSHs(handler);
		if (GIMME == G_ARRAY) {
			XPUSHs(refCon);
		}
	}
#line 1528 "AppleEvents.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__AppleEvents_AEManagerInfo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEManagerInfo)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEManagerInfo(keyWord)");
    {
	OSType	keyWord;
	SysRetLong	RETVAL;

	memcpy(&keyWord, SvPV_nolen(ST(0)), sizeof(OSType));
	keyWord = ntohl(keyWord);
#line 892 "AppleEvents.xs"
	AEFail(AEManagerInfo(keyWord, &RETVAL));
#line 1548 "AppleEvents.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEBuild); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEBuild)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEBuild(format, ...)");
    {
	char *	format = (char *)SvPV_nolen(ST(0));
	AEDesc	RETVAL;
#line 916 "AppleEvents.xs"
	{
		int	item = 1;
		char *formscan = format;

		PAEClearArgs();
		for (;item<items;++item) 
			if (!PAEDoNextParam(&formscan, ST(item)))
				croak("Too many arguments to AEBuild()");

		if (PAENextParam(&formscan))
			croak("Not enough arguments to AEBuild()");
		gMacPerl_OSErr = vAEBuild(&RETVAL, format, gPAEArgs);
#ifndef MACOS_TRADITIONAL
		pAEBuildError();
#endif
		AEFail(gMacPerl_OSErr);
	}
#line 1587 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEBuildParameters); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEBuildParameters)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEBuildParameters(event, format, ...)");
    {
	AEDesc	event;
	char *	format = (char *)SvPV_nolen(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&event, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("event is not of type AEDesc");
#line 950 "AppleEvents.xs"
	{
		int	item = 2;
		char *formscan = format;

		PAEClearArgs();
		for (;item<items;++item) 
			if (!PAEDoNextParam(&formscan, ST(item)))
				croak("Too many arguments to AEBuildParameters()");

		if (PAENextParam(&formscan))
			croak("Not enough arguments to AEBuildParameters()");
		RETVAL = vAEBuildParameters(&event, format, gPAEArgs);
#ifndef MACOS_TRADITIONAL
		pAEBuildError();
#endif
	}
#line 1627 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEBuildAppleEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEBuildAppleEvent)
{
    dXSARGS;
    if (items < 7)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEBuildAppleEvent(theClass, theID, addressType, address, returnID, transactionID, paramsFmt, ...)");
    {
	OSType	theClass;
	OSType	theID;
	OSType	addressType;
	SV *	address = ST(3);
	short	returnID = (short)SvIV(ST(4));
	long	transactionID = (long)SvIV(ST(5));
	char *	paramsFmt = (char *)SvPV_nolen(ST(6));
	AEDesc	RETVAL;

	memcpy(&theClass, SvPV_nolen(ST(0)), sizeof(OSType));
	theClass = ntohl(theClass);

	memcpy(&theID, SvPV_nolen(ST(1)), sizeof(OSType));
	theID = ntohl(theID);

	memcpy(&addressType, SvPV_nolen(ST(2)), sizeof(OSType));
	addressType = ntohl(addressType);
#line 984 "AppleEvents.xs"
	{
		int		item = 7;
		char *	formscan = paramsFmt;
		char *	addressPtr;
		STRLEN	addressLen;
		AEDesc	targetDesc;
		OSErr		error;

		PAEClearArgs();

		for (;item<items;++item) 
			if (!PAEDoNextParam(&formscan, ST(item)))
				croak("Too many arguments to AEBuildAppleEvent()");

		if (PAENextParam(&formscan))
			croak("Not enough arguments to AEBuildAppleEvent()");

		addressPtr = SvPV(address, addressLen);
		ConvertFourCharCode(addressType, addressPtr);

		error = AECreateDesc(addressType, addressPtr, addressLen, &targetDesc);
		ConvertFourCharCode(addressType, addressPtr);
		AEFail(error);

		if (gPAECreate)
			AEFail(
				CallOSACreateAppleEventProc(gPAECreate,
					theClass, theID, 
					&targetDesc, returnID, transactionID, &RETVAL, 
					gPAECreateRefCon));
		else
			AEFail(
				AECreateAppleEvent(
					theClass, theID, 
					&targetDesc, returnID, transactionID, &RETVAL));
		AEDisposeDesc(&targetDesc);
		gMacPerl_OSErr = vAEBuildParameters(&RETVAL, paramsFmt, gPAEArgs);
#ifndef MACOS_TRADITIONAL
		pAEBuildError();
#endif
		AEFail(gMacPerl_OSErr);
	}
#line 1700 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPrint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEPrint)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPrint(desc)");
    {
	AEDesc	desc;
	SV *	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");
#line 1039 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
		Handle	hand;

		AEFail(AEPrintDescToHandle(&desc, &hand));
		RETVAL = newSVpv(*hand, GetHandleSize(hand)-1); // remove null
		DisposeHandle(hand);
#else
		long		length;

		AEFail(AEPrintSize(&desc, &length));
		RETVAL = newSVpv("", length);
		AEPrint(&desc, SvPVX(RETVAL), length);
		SvCUR(RETVAL) = length-1;
#endif
	}
#line 1738 "AppleEvents.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDescToSubDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEDescToSubDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDescToSubDesc(desc)");
    {
	AEDesc	desc;
	AESubDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");
#line 1081 "AppleEvents.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEDescToSubDesc unsupported in Carbon");
#else
	AEDescToSubDesc(&desc, &RETVAL);
#endif
#line 1765 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AESubDesc", (void*)&RETVAL, sizeof(AESubDesc));
    }
    XSRETURN(1);
}

#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAA 1

XS(XS_Mac__AppleEvents_AEGetSubDescType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetSubDescType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1103 "AppleEvents.xs"
	croak("Usage: Mac::AppleEvents::AEGetSubDescType unsupported in Carbon");
#line 1791 "AppleEvents.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAB 1

XS(XS_Mac__AppleEvents_AEGetSubDescType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetSubDescType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	RETVAL = AEGetSubDescType(&subdesc);
	ST(0) = sv_newmortal();
	{ OSType hos = htonl(RETVAL);
	  sv_setpvn(ST(0), (char *) &hos, 4);
	}
    }
    XSRETURN(1);
}

#endif
#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAC 1

XS(XS_Mac__AppleEvents_AEGetSubDescBasicType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetSubDescBasicType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescBasicType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1128 "AppleEvents.xs"
	croak("Usage: Mac::AppleEvents::AEGetSubDescBasicType unsupported in Carbon");
#line 1843 "AppleEvents.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1

XS(XS_Mac__AppleEvents_AEGetSubDescBasicType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetSubDescBasicType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescBasicType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	RETVAL = AEGetSubDescBasicType(&subdesc);
	ST(0) = sv_newmortal();
	{ OSType hos = htonl(RETVAL);
	  sv_setpvn(ST(0), (char *) &hos, 4);
	}
    }
    XSRETURN(1);
}

#endif
#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAE 1

XS(XS_Mac__AppleEvents_AESubDescIsListOrRecord); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESubDescIsListOrRecord)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESubDescIsListOrRecord(subdesc)");
    {
	AESubDesc	subdesc;
	Boolean	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1152 "AppleEvents.xs"
	croak("Usage: Mac::AppleEvents::AESubDescIsListOrRecord unsupported in Carbon");
#line 1895 "AppleEvents.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1

XS(XS_Mac__AppleEvents_AESubDescIsListOrRecord); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESubDescIsListOrRecord)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESubDescIsListOrRecord(subdesc)");
    {
	AESubDesc	subdesc;
	Boolean	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	RETVAL = AESubDescIsListOrRecord(&subdesc);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
XS(XS_Mac__AppleEvents_AEGetSubDescData); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetSubDescData)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescData(subdesc)");
    {
	AESubDesc	subdesc;
	SV *	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1173 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEGetSubDescData unsupported in Carbon");
#else
		void *data;
		long	length;

		data		= AEGetSubDescData(&subdesc, &length);
		RETVAL	= newSVpv(data, length);
#endif
	}
#line 1952 "AppleEvents.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESubDescToDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AESubDescToDesc)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESubDescToDesc(subdesc, desiredType=typeWildCard)");
    {
	AESubDesc	subdesc;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	if (items < 2)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(1)), sizeof(OSType));
	    desiredType = ntohl(desiredType);
	}
#line 1199 "AppleEvents.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AESubDescToDesc unsupported in Carbon");
#else
	AEFail(AESubDescToDesc(&subdesc, desiredType, &RETVAL));
#endif
#line 1987 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECountSubDescItems); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AECountSubDescItems)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECountSubDescItems(subdesc)");
    {
	AESubDesc	subdesc;
	long	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1218 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AECountSubDescItems unsupported in Carbon");
#else
		RETVAL = AECountSubDescItems(&subdesc);
		if (RETVAL < 0)
			AEFail((OSErr) RETVAL);
#endif
	}
#line 2019 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetNthSubDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetNthSubDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetNthSubDesc(subdesc, index)");
    SP -= items;
    {
	AESubDesc	subdesc;
	long	index = (long)SvIV(ST(1));

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1243 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEGetNthSubDesc unsupported in Carbon");
#else
		OSType		kw;
		AESubDesc	sub;

		AEFail(AEGetNthSubDesc(&subdesc, index, &kw, &sub));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "AESubDesc", (void*)&(sub), sizeof(AESubDesc));
		if (GIMME == G_ARRAY && kw != typeWildCard) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((kw));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		}
#endif
	}
#line 2063 "AppleEvents.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__AppleEvents_AEGetKeySubDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__AppleEvents_AEGetKeySubDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetKeySubDesc(subdesc, kw)");
    {
	AESubDesc	subdesc;
	OSType	kw;
	AESubDesc	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	memcpy(&kw, SvPV_nolen(ST(1)), sizeof(OSType));
	kw = ntohl(kw);
#line 1272 "AppleEvents.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEGetKeySubDesc unsupported in Carbon");
#else
	AEFail(AEGetKeySubDesc(&subdesc, kw, &RETVAL));
#endif
#line 2093 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AESubDesc", (void*)&RETVAL, sizeof(AESubDesc));
    }
    XSRETURN(1);
}

XS(XS_AEStream_Open); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_Open)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: AEStream::Open()");
    {
	AEStream	RETVAL;
#line 1299 "AppleEvents.xs"
#ifdef MACOS_TRADITIONAL
	AEFail(AEStream_Open(&RETVAL));
#else
	RETVAL = AEStream_Open();
#endif
#line 2114 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEStream", (void*)&RETVAL, sizeof(AEStream));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CreateEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_CreateEvent)
{
    dXSARGS;
    if (items < 4 || items > 6)
	Perl_croak(aTHX_ "Usage: AEStream::CreateEvent(theClass, theID, addressType, address, returnID=kAutoGenerateReturnID, transactionID=0)");
    {
	OSType	theClass;
	OSType	theID;
	OSType	addressType;
	SV *	address = ST(3);
	short	returnID;
	long	transactionID;
	AEStream	RETVAL;

	memcpy(&theClass, SvPV_nolen(ST(0)), sizeof(OSType));
	theClass = ntohl(theClass);

	memcpy(&theID, SvPV_nolen(ST(1)), sizeof(OSType));
	theID = ntohl(theID);

	memcpy(&addressType, SvPV_nolen(ST(2)), sizeof(OSType));
	addressType = ntohl(addressType);

	if (items < 5)
	    returnID = kAutoGenerateReturnID;
	else {
	    returnID = (short)SvIV(ST(4));
	}

	if (items < 6)
	    transactionID = 0;
	else {
	    transactionID = (long)SvIV(ST(5));
	}
#line 1323 "AppleEvents.xs"
	{
		char *		addressPtr;
		STRLEN		addressLen;
		AEDesc		targetDesc;
		AppleEvent	event;
		OSErr			error;

		addressPtr = SvPV(address, addressLen);
		ConvertFourCharCode(addressType, addressPtr);

		error = AECreateDesc(addressType, addressPtr, addressLen, &targetDesc);
		ConvertFourCharCode(addressType, addressPtr);
		AEFail(error);

		if (gPAECreate)
			AEFail(
				CallOSACreateAppleEventProc(gPAECreate,
					theClass, theID, 
					&targetDesc, returnID, transactionID, &event, 
					gPAECreateRefCon));
		else
			AEFail(
				AECreateAppleEvent(
					theClass, theID, 
					&targetDesc, returnID, transactionID, &event));
		AEDisposeDesc(&targetDesc);
#ifdef MACOS_TRADITIONAL
		AEFail(AEStream_OpenEvent(&RETVAL, &event));
#else
		RETVAL = AEStream_OpenEvent(&event);
#endif
	}
#line 2189 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEStream", (void*)&RETVAL, sizeof(AEStream));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenEvent); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_OpenEvent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::OpenEvent(theEvent)");
    {
	AEDesc	theEvent;
	AEStream	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theEvent is not of type AEDesc");
#line 1370 "AppleEvents.xs"
#ifdef MACOS_TRADITIONAL
	AEFail(AEStream_OpenEvent(&RETVAL, &theEvent));
#else
	RETVAL = AEStream_OpenEvent(&theEvent);
#endif
#line 2216 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEStream", (void*)&RETVAL, sizeof(AEStream));
    }
    XSRETURN(1);
}

XS(XS_AEStream_Close); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_Close)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::Close(stream)");
    {
	AEStream	stream;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1389 "AppleEvents.xs"
	AEFail(AEStream_Close(&stream, &RETVAL));
#line 2239 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_AEStream_Abort); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_Abort)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::Abort(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1405 "AppleEvents.xs"
	RETVAL = AEStream_Close(&stream, nil);
#line 2265 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_OpenDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::OpenDesc(stream, type)");
    {
	AEStream	stream;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	type = ntohl(type);
#line 1430 "AppleEvents.xs"
	RETVAL = AEStream_OpenDesc(&stream, type);
#line 2294 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteData); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_WriteData)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::WriteData(stream, data)");
    {
	AEStream	stream;
	SV *	data = ST(1);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1444 "AppleEvents.xs"
	{
		void *	ptr;
		STRLEN	length;

		ptr = SvPV(data, length);
		RETVAL = AEStream_WriteData(&stream, ptr, length);
	}
#line 2325 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CloseDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_CloseDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::CloseDesc(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1464 "AppleEvents.xs"
	RETVAL = AEStream_CloseDesc(&stream);
#line 2350 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_WriteDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: AEStream::WriteDesc(stream, type, data)");
    {
	AEStream	stream;
	OSType	type;
	SV *	data = ST(2);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	type = ntohl(type);
#line 1479 "AppleEvents.xs"
	{
		char *	ptr;
		STRLEN	length;

		ptr = SvPV(data, length);
		ConvertFourCharCode(type, ptr);

		RETVAL = AEStream_WriteDesc(&stream, type, ptr, length);
		ConvertFourCharCode(type, ptr);
	}
#line 2388 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteAEDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_WriteAEDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::WriteAEDesc(stream, desc)");
    {
	AEStream	stream;
	AEDesc	desc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	if (sv_isa(ST(1), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");
#line 1503 "AppleEvents.xs"
	RETVAL = AEStream_WriteAEDesc(&stream, &desc);
#line 2419 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenList); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_OpenList)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::OpenList(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1516 "AppleEvents.xs"
	RETVAL = AEStream_OpenList(&stream);
#line 2443 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CloseList); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_CloseList)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::CloseList(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1536 "AppleEvents.xs"
	RETVAL = AEStream_CloseList(&stream);
#line 2467 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenRecord); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_OpenRecord)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEStream::OpenRecord(stream, type=typeAERecord)");
    {
	AEStream	stream;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	if (items < 2)
	    type = typeAERecord;
	else {
	    memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	    type = ntohl(type);
	}
#line 1550 "AppleEvents.xs"
	RETVAL = AEStream_OpenRecord(&stream, type);
#line 2499 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_SetRecordType); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_SetRecordType)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::SetRecordType(stream, type)");
    {
	AEStream	stream;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	type = ntohl(type);
#line 1564 "AppleEvents.xs"
	RETVAL = AEStream_SetRecordType(&stream, type);
#line 2527 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CloseRecord); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_CloseRecord)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::CloseRecord(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1585 "AppleEvents.xs"
	RETVAL = AEStream_CloseRecord(&stream);
#line 2551 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteKeyDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_WriteKeyDesc)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: AEStream::WriteKeyDesc(stream, key, type, data)");
    {
	AEStream	stream;
	OSType	key;
	OSType	type;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
	key = ntohl(key);

	memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));
	type = ntohl(type);
#line 1601 "AppleEvents.xs"
	{
		char *	ptr;
		STRLEN	length;

		ptr = SvPV(data, length);
		ConvertFourCharCode(type, ptr);

		RETVAL = AEStream_WriteKeyDesc(&stream, key, type, ptr, length);
		ConvertFourCharCode(type, ptr);
	}
#line 2593 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenKeyDesc); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_OpenKeyDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: AEStream::OpenKeyDesc(stream, key, type)");
    {
	AEStream	stream;
	OSType	key;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
	key = ntohl(key);

	memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));
	type = ntohl(type);
#line 1627 "AppleEvents.xs"
	RETVAL = AEStream_OpenKeyDesc(&stream, key, type);
#line 2626 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteKey); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_WriteKey)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::WriteKey(stream, key)");
    {
	AEStream	stream;
	OSType	key;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
	key = ntohl(key);
#line 1642 "AppleEvents.xs"
	RETVAL = AEStream_WriteKey(&stream, key);
#line 2654 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OptionalParam); /* prototype to pass -Wmissing-prototypes */
XS(XS_AEStream_OptionalParam)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::OptionalParam(stream, key)");
    {
	AEStream	stream;
	OSType	key;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
	key = ntohl(key);
#line 1658 "AppleEvents.xs"
	RETVAL = AEStream_OptionalParam(&stream, key);
#line 2682 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__AppleEvents); /* prototype to pass -Wmissing-prototypes */
XS(boot_Mac__AppleEvents)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("AEDesc::_new", XS_AEDesc__new, file);
        newXS("AEDesc::type", XS_AEDesc_type, file);
        newXS("AEDesc::data", XS_AEDesc_data, file);
        newXS("AEKeyDesc::_new", XS_AEKeyDesc__new, file);
        newXS("AEKeyDesc::key", XS_AEKeyDesc_key, file);
        newXS("AEKeyDesc::type", XS_AEKeyDesc_type, file);
        newXS("AEKeyDesc::data", XS_AEKeyDesc_data, file);
        newXS("AEKeyDesc::desc", XS_AEKeyDesc_desc, file);
        newXS("Mac::AppleEvents::AECreateDesc", XS_Mac__AppleEvents_AECreateDesc, file);
        newXS("Mac::AppleEvents::AECoerce", XS_Mac__AppleEvents_AECoerce, file);
        newXS("Mac::AppleEvents::AECoerceDesc", XS_Mac__AppleEvents_AECoerceDesc, file);
        newXS("Mac::AppleEvents::AEDisposeDesc", XS_Mac__AppleEvents_AEDisposeDesc, file);
        newXS("Mac::AppleEvents::AEDuplicateDesc", XS_Mac__AppleEvents_AEDuplicateDesc, file);
        newXS("Mac::AppleEvents::AECreateList", XS_Mac__AppleEvents_AECreateList, file);
        newXS("Mac::AppleEvents::AECountItems", XS_Mac__AppleEvents_AECountItems, file);
        newXS("Mac::AppleEvents::AEPut", XS_Mac__AppleEvents_AEPut, file);
        newXS("Mac::AppleEvents::AEPutDesc", XS_Mac__AppleEvents_AEPutDesc, file);
        newXS("Mac::AppleEvents::AEPutKey", XS_Mac__AppleEvents_AEPutKey, file);
        newXS("Mac::AppleEvents::AEPutKeyDesc", XS_Mac__AppleEvents_AEPutKeyDesc, file);
        newXS("Mac::AppleEvents::AEGetNthDesc", XS_Mac__AppleEvents_AEGetNthDesc, file);
        newXS("Mac::AppleEvents::AEGetKeyDesc", XS_Mac__AppleEvents_AEGetKeyDesc, file);
        newXS("Mac::AppleEvents::AEDeleteItem", XS_Mac__AppleEvents_AEDeleteItem, file);
        newXS("Mac::AppleEvents::AEPutParam", XS_Mac__AppleEvents_AEPutParam, file);
        newXS("Mac::AppleEvents::AEPutParamDesc", XS_Mac__AppleEvents_AEPutParamDesc, file);
        newXS("Mac::AppleEvents::AEGetParamDesc", XS_Mac__AppleEvents_AEGetParamDesc, file);
        newXS("Mac::AppleEvents::AEDeleteParam", XS_Mac__AppleEvents_AEDeleteParam, file);
        newXS("Mac::AppleEvents::AEGetAttributeDesc", XS_Mac__AppleEvents_AEGetAttributeDesc, file);
        newXS("Mac::AppleEvents::AEPutAttribute", XS_Mac__AppleEvents_AEPutAttribute, file);
        newXS("Mac::AppleEvents::AEPutAttributeDesc", XS_Mac__AppleEvents_AEPutAttributeDesc, file);
        newXS("Mac::AppleEvents::AECreateAppleEvent", XS_Mac__AppleEvents_AECreateAppleEvent, file);
        newXS("Mac::AppleEvents::AESend", XS_Mac__AppleEvents_AESend, file);
        newXS("Mac::AppleEvents::AEResetTimer", XS_Mac__AppleEvents_AEResetTimer, file);
        newXS("Mac::AppleEvents::AESuspendTheCurrentEvent", XS_Mac__AppleEvents_AESuspendTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AEResumeTheCurrentEvent", XS_Mac__AppleEvents_AEResumeTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AEGetTheCurrentEvent", XS_Mac__AppleEvents_AEGetTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AESetTheCurrentEvent", XS_Mac__AppleEvents_AESetTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AEGetInteractionAllowed", XS_Mac__AppleEvents_AEGetInteractionAllowed, file);
        newXS("Mac::AppleEvents::AESetInteractionAllowed", XS_Mac__AppleEvents_AESetInteractionAllowed, file);
        newXS("Mac::AppleEvents::AEInstallEventHandler", XS_Mac__AppleEvents_AEInstallEventHandler, file);
        newXS("Mac::AppleEvents::AERemoveEventHandler", XS_Mac__AppleEvents_AERemoveEventHandler, file);
        newXS("Mac::AppleEvents::AEGetEventHandler", XS_Mac__AppleEvents_AEGetEventHandler, file);
        newXS("Mac::AppleEvents::AEManagerInfo", XS_Mac__AppleEvents_AEManagerInfo, file);
        newXS("Mac::AppleEvents::AEBuild", XS_Mac__AppleEvents_AEBuild, file);
        newXS("Mac::AppleEvents::AEBuildParameters", XS_Mac__AppleEvents_AEBuildParameters, file);
        newXS("Mac::AppleEvents::AEBuildAppleEvent", XS_Mac__AppleEvents_AEBuildAppleEvent, file);
        newXS("Mac::AppleEvents::AEPrint", XS_Mac__AppleEvents_AEPrint, file);
        newXS("Mac::AppleEvents::AEDescToSubDesc", XS_Mac__AppleEvents_AEDescToSubDesc, file);
#if XSubPPtmpAAAA
        newXS("Mac::AppleEvents::AEGetSubDescType", XS_Mac__AppleEvents_AEGetSubDescType, file);
#endif
#if XSubPPtmpAAAB
        newXS("Mac::AppleEvents::AEGetSubDescType", XS_Mac__AppleEvents_AEGetSubDescType, file);
#endif
#if XSubPPtmpAAAC
        newXS("Mac::AppleEvents::AEGetSubDescBasicType", XS_Mac__AppleEvents_AEGetSubDescBasicType, file);
#endif
#if XSubPPtmpAAAD
        newXS("Mac::AppleEvents::AEGetSubDescBasicType", XS_Mac__AppleEvents_AEGetSubDescBasicType, file);
#endif
#if XSubPPtmpAAAE
        newXS("Mac::AppleEvents::AESubDescIsListOrRecord", XS_Mac__AppleEvents_AESubDescIsListOrRecord, file);
#endif
#if XSubPPtmpAAAF
        newXS("Mac::AppleEvents::AESubDescIsListOrRecord", XS_Mac__AppleEvents_AESubDescIsListOrRecord, file);
#endif
        newXS("Mac::AppleEvents::AEGetSubDescData", XS_Mac__AppleEvents_AEGetSubDescData, file);
        newXS("Mac::AppleEvents::AESubDescToDesc", XS_Mac__AppleEvents_AESubDescToDesc, file);
        newXS("Mac::AppleEvents::AECountSubDescItems", XS_Mac__AppleEvents_AECountSubDescItems, file);
        newXS("Mac::AppleEvents::AEGetNthSubDesc", XS_Mac__AppleEvents_AEGetNthSubDesc, file);
        newXS("Mac::AppleEvents::AEGetKeySubDesc", XS_Mac__AppleEvents_AEGetKeySubDesc, file);
        newXS("AEStream::Open", XS_AEStream_Open, file);
        newXS("AEStream::CreateEvent", XS_AEStream_CreateEvent, file);
        newXS("AEStream::OpenEvent", XS_AEStream_OpenEvent, file);
        newXS("AEStream::Close", XS_AEStream_Close, file);
        newXS("AEStream::Abort", XS_AEStream_Abort, file);
        newXS("AEStream::OpenDesc", XS_AEStream_OpenDesc, file);
        newXS("AEStream::WriteData", XS_AEStream_WriteData, file);
        newXS("AEStream::CloseDesc", XS_AEStream_CloseDesc, file);
        newXS("AEStream::WriteDesc", XS_AEStream_WriteDesc, file);
        newXS("AEStream::WriteAEDesc", XS_AEStream_WriteAEDesc, file);
        newXS("AEStream::OpenList", XS_AEStream_OpenList, file);
        newXS("AEStream::CloseList", XS_AEStream_CloseList, file);
        newXS("AEStream::OpenRecord", XS_AEStream_OpenRecord, file);
        newXS("AEStream::SetRecordType", XS_AEStream_SetRecordType, file);
        newXS("AEStream::CloseRecord", XS_AEStream_CloseRecord, file);
        newXS("AEStream::WriteKeyDesc", XS_AEStream_WriteKeyDesc, file);
        newXS("AEStream::OpenKeyDesc", XS_AEStream_OpenKeyDesc, file);
        newXS("AEStream::WriteKey", XS_AEStream_WriteKey, file);
        newXS("AEStream::OptionalParam", XS_AEStream_OptionalParam, file);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#line 2804 "AppleEvents.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

