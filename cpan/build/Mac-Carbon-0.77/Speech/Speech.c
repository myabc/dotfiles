/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Speech.xs. Do not edit this file, edit Speech.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Speech.xs"
/* $Header: /cvsroot/macperl/perl/macos/ext/Mac/Speech/Speech.xs,v 1.5 2006/07/07 06:40:26 pudge Exp $
 *
 *    Copyright (c) 1996 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: Speech.xs,v $
 * Revision 1.5  2006/07/07 06:40:26  pudge
 * Add SpeechToFile
 *
 * Revision 1.4  2002/12/19 17:45:53  pudge
 * GetVoiceDesciption and NewSpeechChannel use default voice if no parameter given
 * %Voice hash returns default voice if key is false (undef, '', 0)
 * Added accessor methods for VoiceDescription and VoiceSpec structures
 *
 * Revision 1.3  2002/11/13 02:04:53  pudge
 * Aieeeeee!  Big ol' Carbon update.
 *
 * Revision 1.2  2000/09/09 22:18:28  neeri
 * Dynamic libraries compile under 5.6
 *
 * Revision 1.1  2000/08/14 03:39:33  neeri
 * Checked into Sourceforge
 *
 * Revision 1.4  1998/04/07 01:03:15  neeri
 * MacPerl 5.2.0r4b1
 *
 * Revision 1.3  1997/11/18 00:53:21  neeri
 * MacPerl 5.1.5
 *
 * Revision 1.2  1997/08/08 16:39:30  neeri
 * MacPerl 5.1.4b1 + time() fix
 *
 * Revision 1.1  1997/04/07 20:50:45  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#endif
#include <Types.h>
#include <Memory.h>
#include <Speech.h>

#ifndef __CFM68K__
#include <FixMath.h>
#else
#define fixed1				((Fixed) 0x00010000L)
#define fract1				((Fract) 0x40000000L)
#define positiveInfinity	((long)  0x7FFFFFFFL)
#define negativeInfinity	((long)  0x80000000L)

extern pascal long double Frac2X(Fract x) = 0xA845;
extern pascal long double Fix2X(Fixed x) = 0xA843;
extern pascal Fixed X2Fix(long double x) = 0xA844;
extern pascal Fract X2Frac(long double x) = 0xA846;
#endif

#ifdef __CFM68K__

#undef FOURWORDINLINE
#define FOURWORDINLINE(w1,w2,w3,w4)  = {w1,w2,w3,w4}

extern pascal NumVersion SpeechManagerVersion(void)
 FOURWORDINLINE(0x203C, 0x0000, 0x000C, 0xA800);

extern pascal OSErr MakeVoiceSpec(OSType creator, OSType id, VoiceSpec *voice)
 FOURWORDINLINE(0x203C, 0x0604, 0x000C, 0xA800);

extern pascal OSErr CountVoices(short *numVoices)
 FOURWORDINLINE(0x203C, 0x0108, 0x000C, 0xA800);

extern pascal OSErr GetIndVoice(short index, VoiceSpec *voice)
 FOURWORDINLINE(0x203C, 0x030C, 0x000C, 0xA800);

extern pascal OSErr GetVoiceDescription(const VoiceSpec *voice, VoiceDescription *info, long infoLength)
 FOURWORDINLINE(0x203C, 0x0610, 0x000C, 0xA800);

extern pascal OSErr GetVoiceInfo(const VoiceSpec *voice, OSType selector, void *voiceInfo)
 FOURWORDINLINE(0x203C, 0x0614, 0x000C, 0xA800);

extern pascal OSErr NewSpeechChannel(VoiceSpec *voice, SpeechChannel *chan)
 FOURWORDINLINE(0x203C, 0x0418, 0x000C, 0xA800);

extern pascal OSErr DisposeSpeechChannel(SpeechChannel chan)
 FOURWORDINLINE(0x203C, 0x021C, 0x000C, 0xA800);

extern pascal OSErr SpeakString(ConstStr255Param s)
 FOURWORDINLINE(0x203C, 0x0220, 0x000C, 0xA800);

extern pascal OSErr SpeakText(SpeechChannel chan, const void * textBuf, unsigned long textBytes)
 FOURWORDINLINE(0x203C, 0x0624, 0x000C, 0xA800);

extern pascal OSErr SpeakBuffer(SpeechChannel chan, const void * textBuf, unsigned long textBytes, long controlFlags)
 FOURWORDINLINE(0x203C, 0x0828, 0x000C, 0xA800);

extern pascal OSErr StopSpeech(SpeechChannel chan)
 FOURWORDINLINE(0x203C, 0x022C, 0x000C, 0xA800);

extern pascal OSErr StopSpeechAt(SpeechChannel chan, long whereToStop)
 FOURWORDINLINE(0x203C, 0x0430, 0x000C, 0xA800);

extern pascal OSErr PauseSpeechAt(SpeechChannel chan, long whereToPause)
 FOURWORDINLINE(0x203C, 0x0434, 0x000C, 0xA800);

extern pascal OSErr ContinueSpeech(SpeechChannel chan)
 FOURWORDINLINE(0x203C, 0x0238, 0x000C, 0xA800);

extern pascal short SpeechBusy(void)
 FOURWORDINLINE(0x203C, 0x003C, 0x000C, 0xA800);

extern pascal short SpeechBusySystemWide(void)
 FOURWORDINLINE(0x203C, 0x0040, 0x000C, 0xA800);

extern pascal OSErr SetSpeechRate(SpeechChannel chan, Fixed rate)
 FOURWORDINLINE(0x203C, 0x0444, 0x000C, 0xA800);

extern pascal OSErr GetSpeechRate(SpeechChannel chan, Fixed *rate)
 FOURWORDINLINE(0x203C, 0x0448, 0x000C, 0xA800);

extern pascal OSErr SetSpeechPitch(SpeechChannel chan, Fixed pitch)
 FOURWORDINLINE(0x203C, 0x044C, 0x000C, 0xA800);

extern pascal OSErr GetSpeechPitch(SpeechChannel chan, Fixed *pitch)
 FOURWORDINLINE(0x203C, 0x0450, 0x000C, 0xA800);

extern pascal OSErr SetSpeechInfo(SpeechChannel chan, OSType selector, const void *speechInfo)
 FOURWORDINLINE(0x203C, 0x0654, 0x000C, 0xA800);

extern pascal OSErr GetSpeechInfo(SpeechChannel chan, OSType selector, void *speechInfo)
 FOURWORDINLINE(0x203C, 0x0658, 0x000C, 0xA800);

extern pascal OSErr TextToPhonemes(SpeechChannel chan, const void * textBuf, unsigned long textBytes, Handle phonemeBuf, long *phonemeBytes)
 FOURWORDINLINE(0x203C, 0x0A5C, 0x000C, 0xA800);

extern pascal OSErr UseDictionary(SpeechChannel chan, Handle dictionary)
 FOURWORDINLINE(0x203C, 0x0460, 0x000C, 0xA800);

#endif

#define SpeechFail(error)	if (gMacPerl_OSErr = (error)) { XSRETURN_UNDEF; } else 0

#line 160 "Speech.c"
XS(XS_Mac__Speech_VoiceDescription)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	VoiceDescription STRUCT;

#line 152 "Speech.xs"
	 STRUCT;

	if (sv_isa( ST(0), "VoiceDescription"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(VoiceDescription));
	else
	    croak(" STRUCT is not of type VoiceDescription");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* length */
#line 173 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.length));
		break;
	    case 1:	  /* voice */
#line 174 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "VoiceSpec", (void*)&(STRUCT.voice), sizeof(VoiceSpec));
		break;
	    case 2:	  /* version */
#line 175 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.version));
		break;
	    case 3:	  /* name */
#line 176 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.name)) + 1, (STRUCT.name)[0]);
		break;
	    case 4:	  /* comment */
#line 177 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT.comment)) + 1, (STRUCT.comment)[0]);
		break;
	    case 5:	  /* gender */
#line 178 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.gender));
		break;
	    case 6:	  /* age */
#line 179 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.age));
		break;
	    case 7:	  /* script */
#line 180 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.script));
		break;
	    case 8:	  /* language */
#line 181 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.language));
		break;
	    case 9:	  /* region */
#line 182 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.region));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* length */
#line 173 "Speech.xs"
	 STRUCT.length = (long)SvIV( ST(1));
		break;
	    case 1:	  /* voice */
#line 174 "Speech.xs"
	 STRUCT.voice;

	if (sv_isa( ST(1), "VoiceSpec"))
	    memcpy(& STRUCT.voice, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(VoiceSpec));
	else
	    croak(" STRUCT.voice is not of type VoiceSpec");
		break;
	    case 2:	  /* version */
#line 175 "Speech.xs"
	 STRUCT.version = (long)SvIV( ST(1));
		break;
	    case 3:	  /* name */
#line 176 "Speech.xs"
	 STRUCT.name;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.name);
		break;
	    case 4:	  /* comment */
#line 177 "Speech.xs"
	 STRUCT.comment;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT.comment);
		break;
	    case 5:	  /* gender */
#line 178 "Speech.xs"
	 STRUCT.gender = (short)SvIV( ST(1));
		break;
	    case 6:	  /* age */
#line 179 "Speech.xs"
	 STRUCT.age = (short)SvIV( ST(1));
		break;
	    case 7:	  /* script */
#line 180 "Speech.xs"
	 STRUCT.script = (short)SvIV( ST(1));
		break;
	    case 8:	  /* language */
#line 181 "Speech.xs"
	 STRUCT.language = (short)SvIV( ST(1));
		break;
	    case 9:	  /* region */
#line 182 "Speech.xs"
	 STRUCT.region = (short)SvIV( ST(1));
		break;
	    }
#line 152 "Speech.xs"
	sv_setref_pvn( ST(0), "VoiceDescription", (void*)&( STRUCT), sizeof(VoiceDescription));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_VoiceSpec)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	VoiceSpec STRUCT;

#line 184 "Speech.xs"
	 STRUCT;

	if (sv_isa( ST(0), "VoiceSpec"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(VoiceSpec));
	else
	    croak(" STRUCT is not of type VoiceSpec");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* creator */
#line 194 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT.creator));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    case 1:	  /* id */
#line 195 "Speech.xs"
	++sp;
	*sp = sv_newmortal();
	{ OSType hos = htonl((STRUCT.id));
	  sv_setpvn(*sp, (char *) &hos, 4);
	}
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* creator */
#line 194 "Speech.xs"
	 STRUCT.creator;

	memcpy(& STRUCT.creator, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT.creator = ntohl( STRUCT.creator);
		break;
	    case 1:	  /* id */
#line 195 "Speech.xs"
	 STRUCT.id;

	memcpy(& STRUCT.id, SvPV_nolen( ST(1)), sizeof(OSType));
	 STRUCT.id = ntohl( STRUCT.id);
		break;
	    }
#line 184 "Speech.xs"
	sv_setref_pvn( ST(0), "VoiceSpec", (void*)&( STRUCT), sizeof(VoiceSpec));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeechManagerVersion); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeechManagerVersion)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeechManagerVersion()");
    {
	NumVersion	RETVAL;

	RETVAL = SpeechManagerVersion();
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "NumVersion", (void*)&RETVAL, sizeof(NumVersion));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_CountVoices); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_CountVoices)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Speech::CountVoices()");
    {
	short	RETVAL;
	dXSTARG;
#line 216 "Speech.xs"
	SpeechFail(CountVoices(&RETVAL));
#line 387 "Speech.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_GetIndVoice); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_GetIndVoice)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::GetIndVoice(index)");
    {
	short	index = (short)SvIV(ST(0));
	VoiceSpec	RETVAL;
#line 228 "Speech.xs"
	SpeechFail(GetIndVoice(index, &RETVAL));
#line 404 "Speech.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "VoiceSpec", (void*)&RETVAL, sizeof(VoiceSpec));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_GetVoiceDescription); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_GetVoiceDescription)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::GetVoiceDescription(voice=NO_INIT)");
    {
	VoiceSpec	voice;
	VoiceDescription	RETVAL;

	if (items >= 1) {
	    if (sv_isa(ST(0), "VoiceSpec"))
		memcpy(&voice, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(VoiceSpec));
	    else
		croak("voice is not of type VoiceSpec");
	}
#line 240 "Speech.xs"
	if (items >= 1)
		SpeechFail(GetVoiceDescription(&voice, &RETVAL, sizeof(RETVAL)));
	else
		SpeechFail(GetVoiceDescription(NULL, &RETVAL, sizeof(RETVAL)));
#line 432 "Speech.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "VoiceDescription", (void*)&RETVAL, sizeof(VoiceDescription));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_NewSpeechChannel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_NewSpeechChannel)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::NewSpeechChannel(voice=NO_INIT)");
    {
	VoiceSpec	voice;
	SpeechChannel	RETVAL;
	dXSTARG;

	if (items >= 1) {
	    if (sv_isa(ST(0), "VoiceSpec"))
		memcpy(&voice, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(VoiceSpec));
	    else
		croak("voice is not of type VoiceSpec");
	}
#line 255 "Speech.xs"
	if (items >= 1)
		SpeechFail(NewSpeechChannel(&voice, &RETVAL));
	else
		SpeechFail(NewSpeechChannel(NULL, &RETVAL));
#line 461 "Speech.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_DisposeSpeechChannel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_DisposeSpeechChannel)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::DisposeSpeechChannel(chan)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = DisposeSpeechChannel(chan);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeakString); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeakString)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeakString(s)");
    {
	Str255	s;
	MacOSRet	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(0)), s);

	RETVAL = SpeakString(s);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeakText); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeakText)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeakText(chan, text)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	SV *	text = ST(1);
	MacOSRet	RETVAL;
	dXSTARG;
#line 287 "Speech.xs"
	{
		void *	textPtr;
		STRLEN	textSize;

		textPtr = 	SvPV(text, textSize);
		RETVAL	= 	SpeakText(chan, textPtr, textSize);
	}
#line 522 "Speech.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeakBuffer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeakBuffer)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeakBuffer(chan, text, controlFlags)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	SV *	text = ST(1);
	long	controlFlags = (long)SvIV(ST(2));
	MacOSRet	RETVAL;
	dXSTARG;
#line 307 "Speech.xs"
	{
		void *	textPtr;
		STRLEN	textSize;

		textPtr = 	SvPV(text, textSize);
		RETVAL	= 	SpeakBuffer(chan, textPtr, textSize, controlFlags);
	}
#line 548 "Speech.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_StopSpeech); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_StopSpeech)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::StopSpeech(chan)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = StopSpeech(chan);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_StopSpeechAt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_StopSpeechAt)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::StopSpeechAt(chan, whereToStop)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	long	whereToStop = (long)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = StopSpeechAt(chan, whereToStop);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_PauseSpeechAt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_PauseSpeechAt)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::PauseSpeechAt(chan, whereToPause)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	long	whereToPause = (long)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = PauseSpeechAt(chan, whereToPause);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_ContinueSpeech); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_ContinueSpeech)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::ContinueSpeech(chan)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = ContinueSpeech(chan);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeechBusy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeechBusy)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeechBusy()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = SpeechBusy();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeechBusySystemWide); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeechBusySystemWide)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeechBusySystemWide()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = SpeechBusySystemWide();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SetSpeechRate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SetSpeechRate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SetSpeechRate(chan, rate)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	Fixed	rate = X2Fix(SvNV(ST(1)));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SetSpeechRate(chan, rate);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_GetSpeechRate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_GetSpeechRate)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::GetSpeechRate(chan)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	Fixed	RETVAL;
	dXSTARG;
#line 382 "Speech.xs"
	SpeechFail(GetSpeechRate(chan, &RETVAL));
#line 686 "Speech.c"
	XSprePUSH; PUSHn(Fix2X(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SetSpeechPitch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SetSpeechPitch)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SetSpeechPitch(chan, pitch)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	Fixed	pitch = X2Fix(SvNV(ST(1)));
	MacOSRet	RETVAL;
	dXSTARG;

	RETVAL = SetSpeechPitch(chan, pitch);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_GetSpeechPitch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_GetSpeechPitch)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Speech::GetSpeechPitch(chan)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	Fixed	RETVAL;
	dXSTARG;
#line 403 "Speech.xs"
	SpeechFail(GetSpeechPitch(chan, &RETVAL));
#line 722 "Speech.c"
	XSprePUSH; PUSHn(Fix2X(RETVAL));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_TextToPhonemes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_TextToPhonemes)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::TextToPhonemes(chan, text)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	SV *	text = ST(1);
	SV *	RETVAL;
#line 415 "Speech.xs"
	{
		void *	textPtr;
		STRLEN	textSize;
		long	phonSize;
		Handle	h;

		textPtr = 	SvPV(text, textSize);
		h = NewHandle(textSize*3+1024);
		SpeechFail(TextToPhonemes(chan, textPtr, textSize, h, &phonSize));
		HLock(h);
		RETVAL	= 	newSVpv(*h, phonSize);
		DisposeHandle(h);
	}
#line 752 "Speech.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__Speech_SpeechToFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_Mac__Speech_SpeechToFile)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Speech::SpeechToFile(chan, path)");
    {
	SpeechChannel	chan = (SpeechChannel)SvIV(ST(0));
	CFStringRef	path = CFStringCreateWithCString(NULL, (char *) SvPV_nolen(ST(1)), kCFStringEncodingISOLatin1);
	MacOSRet	RETVAL;
	dXSTARG;
#line 441 "Speech.xs"
	{
		CFURLRef cfurlr = CFURLCreateWithFileSystemPath(
			kCFAllocatorDefault, path,
#ifdef MACOS_TRADITIONAL
			kCFURLHFSPathStyle,
#else
			kCFURLPOSIXPathStyle,
#endif
			false
		);

		RETVAL = SetSpeechInfo(chan, soOutputToFileWithCFURL, cfurlr);

	}
#line 785 "Speech.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__Speech); /* prototype to pass -Wmissing-prototypes */
XS(boot_Mac__Speech)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        cv = newXS("VoiceDescription::length", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("VoiceDescription::voice", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("VoiceDescription::version", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("VoiceDescription::name", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("VoiceDescription::comment", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("VoiceDescription::gender", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("VoiceDescription::age", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 6 ; 
        cv = newXS("VoiceDescription::script", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 7 ; 
        cv = newXS("VoiceDescription::language", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 8 ; 
        cv = newXS("VoiceDescription::region", XS_Mac__Speech_VoiceDescription, file);
        XSANY.any_i32 = 9 ; 
        cv = newXS("VoiceSpec::creator", XS_Mac__Speech_VoiceSpec, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("VoiceSpec::id", XS_Mac__Speech_VoiceSpec, file);
        XSANY.any_i32 = 1 ; 
        newXS("Mac::Speech::SpeechManagerVersion", XS_Mac__Speech_SpeechManagerVersion, file);
        newXS("Mac::Speech::CountVoices", XS_Mac__Speech_CountVoices, file);
        newXS("Mac::Speech::GetIndVoice", XS_Mac__Speech_GetIndVoice, file);
        newXS("Mac::Speech::GetVoiceDescription", XS_Mac__Speech_GetVoiceDescription, file);
        newXS("Mac::Speech::NewSpeechChannel", XS_Mac__Speech_NewSpeechChannel, file);
        newXS("Mac::Speech::DisposeSpeechChannel", XS_Mac__Speech_DisposeSpeechChannel, file);
        newXS("Mac::Speech::SpeakString", XS_Mac__Speech_SpeakString, file);
        newXS("Mac::Speech::SpeakText", XS_Mac__Speech_SpeakText, file);
        newXS("Mac::Speech::SpeakBuffer", XS_Mac__Speech_SpeakBuffer, file);
        newXS("Mac::Speech::StopSpeech", XS_Mac__Speech_StopSpeech, file);
        newXS("Mac::Speech::StopSpeechAt", XS_Mac__Speech_StopSpeechAt, file);
        newXS("Mac::Speech::PauseSpeechAt", XS_Mac__Speech_PauseSpeechAt, file);
        newXS("Mac::Speech::ContinueSpeech", XS_Mac__Speech_ContinueSpeech, file);
        newXS("Mac::Speech::SpeechBusy", XS_Mac__Speech_SpeechBusy, file);
        newXS("Mac::Speech::SpeechBusySystemWide", XS_Mac__Speech_SpeechBusySystemWide, file);
        newXS("Mac::Speech::SetSpeechRate", XS_Mac__Speech_SetSpeechRate, file);
        newXS("Mac::Speech::GetSpeechRate", XS_Mac__Speech_GetSpeechRate, file);
        newXS("Mac::Speech::SetSpeechPitch", XS_Mac__Speech_SetSpeechPitch, file);
        newXS("Mac::Speech::GetSpeechPitch", XS_Mac__Speech_GetSpeechPitch, file);
        newXS("Mac::Speech::TextToPhonemes", XS_Mac__Speech_TextToPhonemes, file);
        newXS("Mac::Speech::SpeechToFile", XS_Mac__Speech_SpeechToFile, file);
    XSRETURN_YES;
}

