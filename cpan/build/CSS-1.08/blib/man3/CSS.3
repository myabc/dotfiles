.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CSS 3"
.TH CSS 3 "2008-04-23" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
CSS \- Object oriented access to Cascading Style Sheets (CSS)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use CSS;
.Ve
.PP
.Vb 2
\&  # create a CSS object with the default options  
\&  my $css = CSS->new();
.Ve
.PP
.Vb 4
\&  # create a CSS object with a specific parser
\&  my $css = CSS->new( { 'parser' => 'CSS::Parse::Lite' } );
\&  my $css = CSS->new( { 'parser' => 'CSS::Parse::Heavy' } );
\&  my $css = CSS->new( { 'parser' => 'CSS::Parse::Compiled' } );
.Ve
.PP
.Vb 4
\&  # create a CSS object with a specific adaptor
\&  my $css = CSS->new( { 'adaptor' => 'CSS::Adaptor' } );
\&  my $css = CSS->new( { 'adaptor' => 'CSS::Adaptor::Pretty' } );
\&  my $css = CSS->new( { 'adaptor' => 'CSS::Adaptor::Debug' } );
.Ve
.PP
.Vb 3
\&  # parse some CSS from a string
\&  $css->read_string( $css_data );
\&  $css->read_string( ( $css_data, $more_css_data ) );
.Ve
.PP
.Vb 3
\&  # parse some CSS from a file
\&  $css->read_file( 'my_file.css' );
\&  $css->read_file( ( 'my_file.css', 'my_other_file.css' ) );
.Ve
.PP
.Vb 2
\&  # output the CSS using the current adaptor
\&  print $css->output();
.Ve
.PP
.Vb 3
\&  # set a new adaptor and then output the CSS
\&  $css->set_adaptor( 'CSS::Adaptor::Foo' );
\&  print $css->output();
.Ve
.PP
.Vb 2
\&  # output the CSS using a tempory adaptor
\&  print $css->output( 'CSS::Adaptor::Bar' );
.Ve
.PP
.Vb 2
\&  # forget about the CSS we've already parsed
\&  $css->purge();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can be used, along with a CSS::Parse::* module, to parse
\&\s-1CSS\s0 data and represent it as a tree of objects. Using a CSS::Adaptor::*
module, the \s-1CSS\s0 data tree can then be transformed into other formats.
.SH "NOTICE"
.IX Header "NOTICE"
From version 1.00 of this module onwards, backwards compatibility is
broken. This is due to large changes in the way data is parsed and
then represented internally. Version 0.08 is still available on
\&\s-1CPAN:\s0 <http://search.cpan.org/author/IAMCAL/CSS\-0.08/>
.SH "TREE STRUCTURE"
.IX Header "TREE STRUCTURE"
The \s-1CSS\s0 object is the head of the tree. It contains a list of 
CSS::Style objects which each represent a \s-1CSS\s0 ruleset. Each of
these objects contains a list of selectors and properties. Each
selector is stored as a CSS::Selector object. Each property
object is stored as a CSS::Property object and contains a list
of values. These values are stored as CSS::Value objects.
.PP
.Vb 4
\&  foo, bar {
\&      baz: fop;
\&      woo: yay houpla;
\&  }
.Ve
.PP
The above example would be represented as a single CSS::Style object.
That object would then have two CSS::Selector objects representing
\&'foo' and 'bar'. It would also have two CSS::Property objects 
representing 'baz' and 'woo'. The 'baz' object then has a single child
CSS::Value object for 'fop', whilst the 'woo' object has two
child objects for 'yay' and 'houpla'.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.ie n .IP """new()""\fR or \f(CW""new( { ..options.. } )""" 4
.el .IP "\f(CWnew()\fR or \f(CWnew( { ..options.. } )\fR" 4
.IX Item "new() or new( { ..options.. } )"
An optional hash can contain arguments:
.Sp
.Vb 2
\&  parser        module to use as the CSS parser
\&  adaptor       adaptor to use for output
.Ve
.Sh "\s-1ACCESSORS\s0"
.IX Subsection "ACCESSORS"
.ie n .IP """read_file( $filename )""\fR or \f(CW""read_file( @filenames )""" 4
.el .IP "\f(CWread_file( $filename )\fR or \f(CWread_file( @filenames )\fR" 4
.IX Item "read_file( $filename ) or read_file( @filenames )"
Read one or mores files and parse the \s-1CSS\s0 within them.
.ie n .IP """read_string( $scalar )""\fR or \f(CW""read_string( @strings )""" 4
.el .IP "\f(CWread_string( $scalar )\fR or \f(CWread_string( @strings )\fR" 4
.IX Item "read_string( $scalar ) or read_string( @strings )"
Read one or more strings and parse the \s-1CSS\s0 within them.
.ie n .IP """output()""\fR or \f(CW""output( 'CSS::Adaptor::Foo' )""" 4
.el .IP "\f(CWoutput()\fR or \f(CWoutput( 'CSS::Adaptor::Foo' )\fR" 4
.IX Item "output() or output( 'CSS::Adaptor::Foo' )"
Return a string representation of the \s-1CSS\s0 tree, using either the 
current adaptor or the specified one.
.ie n .IP """set_adaptor( 'CSS::Adaptor::Bar' )""" 4
.el .IP "\f(CWset_adaptor( 'CSS::Adaptor::Bar' )\fR" 4
.IX Item "set_adaptor( 'CSS::Adaptor::Bar' )"
Set the current adaptor for the \s-1CSS\s0 tree.
.ie n .IP """purge()""" 4
.el .IP "\f(CWpurge()\fR" 4
.IX Item "purge()"
Forget all the objects in the \s-1CSS\s0 tree;
.ie n .IP """get_style_by_selector( 'selector_name' )""" 4
.el .IP "\f(CWget_style_by_selector( 'selector_name' )\fR" 4
.IX Item "get_style_by_selector( 'selector_name' )"
Returns the first CSS::Style object with the specified selector
name attached. Returns zero on failure.
.SH "AUTHORS"
.IX Header "AUTHORS"
Copyright (C) 2001\-2002, Allen Day <allenday@ucla.edu>
.PP
Copyright (C) 2003\-2004, Cal Henderson <cal@iamcal.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CSS::Style, CSS::Selector, CSS::Property, CSS::Value, 
CSS::Parse, CSS::Parse::Lite, CSS::Parse::Heavy, 
CSS::Parse::Compiled, CSS::Parse::PRDGrammar, CSS::Adaptor, 
CSS::Adaptor::Pretty, CSS::Adaptor::Debug, \fIperl\fR\|(1)
