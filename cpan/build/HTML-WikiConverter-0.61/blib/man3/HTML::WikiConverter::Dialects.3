.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::WikiConverter::Dialects 3"
.TH HTML::WikiConverter::Dialects 3 "2006-07-21" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
HTML::WikiConverter::Dialects \- How to add a dialect
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # In your dialect module:
.Ve
.PP
.Vb 2
\&  package HTML::WikiConverter::MySlimWiki;
\&  use HTML::WikiConverter -dialect;
.Ve
.PP
.Vb 5
\&  rule b => { start => '**', end => '**' };
\&  rule i => { start => '//', end => '//' };
\&  rule strong => { alias => 'b' };
\&  rule em => { alias => 'i' };
\&  rule hr => { replace => "\en----\en" };
.Ve
.PP
.Vb 1
\&  # In a nearby piece of code:
.Ve
.PP
.Vb 2
\&  package main;
\&  use Test::More tests => 5;
.Ve
.PP
.Vb 3
\&  my $wc = new HTML::WikiConverter(
\&    dialect => 'MySlimWiki'
\&  );
.Ve
.PP
.Vb 5
\&  is( $wc->html2wiki( '<b>text</b>' ), '**text**', b );
\&  is( $wc->html2wiki( '<i>text</i>' ), '//text//', i );
\&  is( $wc->html2wiki( '<strong>text</strong>' ), '**text**', 'strong' );
\&  is( $wc->html2wiki( '<em>text</em>' ), '//text//', 'em' );
\&  is( $wc->html2wiki( '<hr/>' ), '----', 'hr' );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTML::WikiConverter (or H::WC, for short) is an \s-1HTML\s0 to wiki
converter. It can convert \s-1HTML\s0 source into a variety of wiki markups,
called wiki \*(L"dialects\*(R".  This manual describes how you to create your
own dialect to be plugged into HTML::WikiConverter.
.SH "DIALECTS"
.IX Header "DIALECTS"
Each dialect has a separate dialect module containing rules for
converting \s-1HTML\s0 into wiki markup specific for that dialect. Currently,
all dialect modules are in the \f(CW\*(C`HTML::WikiConverter::\*(C'\fR package space
and subclass HTML::WikiConverter. For example, the MediaWiki dialect
module is HTML::WikiConverter::MediaWiki, while PhpWiki's is
HTML::WikiConverter::PhpWiki. However, dialect modules need not be
in the \f(CW\*(C`HTML::WikiConverter::\*(C'\fR package space; you may just as easily
use \f(CW\*(C`package MyWikiDialect;\*(C'\fR and H::WC will Do The Right Thing.
.PP
From now on, I'll be using the terms \*(L"dialect\*(R" and \*(L"dialect module\*(R"
interchangeably.
.Sh "Subclassing"
.IX Subsection "Subclassing"
To interface with H::WC, dialects need to subclass it. Because you'll
probably be wanting the \f(CW\*(C`rule()\*(C'\fR and \f(CW\*(C`attribute()\*(C'\fR functions as
well, subclassing and importing these functions is done in a single
step:
.PP
.Vb 1
\&  use HTML::WikiConverter -dialect;
.Ve
.PP
This will add HTML::WikiConverter to your dialect's \f(CW@ISA\fR and will
import the \f(CW\*(C`attribute()\*(C'\fR and \f(CW\*(C`rule()\*(C'\fR functions into your dialect's
package.
.Sh "Conversion rules"
.IX Subsection "Conversion rules"
Dialects guide H::WC's conversion process with a set of rules that
define how \s-1HTML\s0 elements are turned into their wiki counterparts.
Each rule corresponds to an \s-1HTML\s0 tag (including nonstandard tags), and
there may be any number of rules. Rules are added with the \f(CW\*(C`rule()\*(C'\fR
function that was imported when you subclassed H::WC (see above).
.PP
The syntax for \f(CW\*(C`rule()\*(C'\fR is as follows:
.PP
.Vb 1
\&    rule $tag => \e%subrules;
.Ve
.PP
where \f(CW$tag\fR is the name of the \s-1HTML\s0 tag (e.g., \f(CW"b"\fR, \f(CW"em"\fR, etc.)
and \f(CW%subrules\fR contains subrules that specify how that tag will be
converted.
.PP
\fISubrules\fR
.IX Subsection "Subrules"
.PP
The following subrules are recognized:
.PP
.Vb 2
\&  start
\&  end
.Ve
.PP
.Vb 3
\&  preserve
\&  attributes
\&  empty
.Ve
.PP
.Vb 2
\&  replace
\&  alias
.Ve
.PP
.Vb 3
\&  block
\&  line_format
\&  line_prefix
.Ve
.PP
.Vb 1
\&  trim
.Ve
.PP
\fIA simple example\fR
.IX Subsection "A simple example"
.PP
The following rules could be used for a dialect that uses
\&\f(CW\*(C`*asterisks*\*(C'\fR for bold and \f(CW\*(C`_underscores_\*(C'\fR for italic text:
.PP
.Vb 2
\&  rule b => { start => '*', end => '*' };
\&  rule i => { start => '_', end => '_' };
.Ve
.PP
\fIAliases\fR
.IX Subsection "Aliases"
.PP
To add \f(CW\*(C`<strong>\*(C'\fR and \f(CW\*(C`<em>\*(C'\fR as aliases of \f(CW\*(C`<b>\*(C'\fR and
\&\f(CW\*(C`<i>\*(C'\fR, use the \f(CW\*(C`alias\*(C'\fR subrule:
.PP
.Vb 2
\&  rule b => { start => '*', end => '*' };
\&  rule i => { start => '_', end => '_' };
.Ve
.PP
.Vb 2
\&  rule strong => { alias => 'b' };
\&  rule em => { alias => 'i' };
.Ve
.PP
(The \f(CW\*(C`alias\*(C'\fR subrule cannot be used with any other subrule.)
.PP
\fIBlocks\fR
.IX Subsection "Blocks"
.PP
Many dialects separate paragraphs and other block-level elements
with a blank line. To indicate this, use the \f(CW\*(C`block\*(C'\fR subrule:
.PP
.Vb 1
\&  rule p => { block => 1 };
.Ve
.PP
(To better support nested block elements, if a block elements are
nested inside each other, blank lines are only added to the outermost
element.)
.PP
\fILine formatting\fR
.IX Subsection "Line formatting"
.PP
Many dialects require that the text of an element be contained on a
single line of text, or that it cannot contain any newlines,
etc. These options can be specified using the \f(CW\*(C`line_format\*(C'\fR subrule,
which can be assigned the value \f(CW"single"\fR, \f(CW"multi"\fR, or
\&\f(CW"blocks"\fR.
.PP
If the element must be contained on a single line, then the
\&\f(CW\*(C`line_format\*(C'\fR subrule should be \f(CW"single"\fR. If the element can span
multiple lines, but there can be no blank lines contained within, then
use \f(CW"multi"\fR. If blank lines (which delimit blocks) are allowed,
then use \f(CW"blocks"\fR. For example, paragraphs are specified like so in
the MediaWiki dialect:
.PP
.Vb 1
\&  rule p => { block => 1, line_format => 'multi', trim => 'both' };
.Ve
.PP
\fITrimming whitespace\fR
.IX Subsection "Trimming whitespace"
.PP
The \f(CW\*(C`trim\*(C'\fR subrule specifies whether leading or trailing whitespace
(or both) should be stripped from the element. To strip leading
whitespace only, use \f(CW"leading"\fR; for trailing whitespace, use
\&\f(CW"trailing"\fR; for both, use the aptly named \f(CW"both"\fR; for neither
(the default), use \f(CW"none"\fR.
.PP
\fILine prefixes\fR
.IX Subsection "Line prefixes"
.PP
Some elements require that each line be prefixed with a particular
string. This is specified with the \f(CW\*(C`line_prefix\*(C'\fR subrule. For
example, preformatted text in MediaWiki is prefixed with a space:
.PP
.Vb 1
\&  rule pre => { block => 1, line_prefix => ' ' };
.Ve
.PP
There is a known bug in H::WC (see
<https://rt.cpan.org/Ticket/Display.html?id=14527>) with the
processing of whitespace that causes line prefixes to be removed from
the wiki markup after conversion. I'm working on a fix for this.
.PP
\fIReplacement\fR
.IX Subsection "Replacement"
.PP
In some cases, conversion from \s-1HTML\s0 to wiki markup is as simple as
string replacement. To replace a tag and its contents with a
particular string, use the \f(CW\*(C`replace\*(C'\fR subrule. For example, in
PhpWiki, three percent signs, \f(CW"%%%"\fR, represents a line break,
\&\f(CW\*(C`<br>\*(C'\fR, hence:
.PP
.Vb 1
\&  rule br => { replace => '%%%' };
.Ve
.PP
(The \f(CW\*(C`replace\*(C'\fR subrule cannot be used with any other rule.)
.PP
\fIPreserving \s-1HTML\s0 tags\fR
.IX Subsection "Preserving HTML tags"
.PP
Some dialects allow a subset of \s-1HTML\s0 in their markup. While H::WC
ignores unhandled \s-1HTML\s0 tags by default (i.e., if H::WC encounters a
tag that does not exist in a dialect's rule specification, then the
contents of the tag is simply passed through to the wiki markup), you
may specify that some be preserved using the \f(CW\*(C`preserve\*(C'\fR subrule. For
example, to allow \f(CW\*(C`<font>\*(C'\fR tag in wiki markup:
.PP
.Vb 1
\&  rule font => { preserve => 1 };
.Ve
.PP
Preserved tags may also specify a list of attributes that may also
passthrough from \s-1HTML\s0 to wiki markup. This is done with the
\&\f(CW\*(C`attributes\*(C'\fR subrule:
.PP
.Vb 1
\&  rule font => { preserve => 1, attributes => [ qw/ style class / ] };
.Ve
.PP
(The \f(CW\*(C`attributes\*(C'\fR subrule can only be used if the \f(CW\*(C`preserve\*(C'\fR subrule
is also present.)
.PP
Some \s-1HTML\s0 elements have no content (e.g., line breaks, images) and the
wiki dialect might require them to be preserved in a more
XHTML-friendly way. To indicate that a preserved tag should have no
content, use the \f(CW\*(C`empty\*(C'\fR subrule. This will cause the element to be
replaced with \f(CW"<tag />"\fR and no end tag. For example,
MediaWiki handles line breaks like so:
.PP
.Vb 5
\&  rule br => {
\&    preserve => 1,
\&    attributes => [ qw/ id class title style clear / ],
\&    empty => 1
\&  };
.Ve
.PP
This will convert, for example, \f(CW"<br clear='both'>"\fR into
\&\f(CW"<br clear='both' />"\fR. Without specifying the \f(CW\*(C`empty\*(C'\fR
subrule, this would be converted into the (probably undesirable)
\&\f(CW"<br clear='both'></br>"\fR.
.PP
(The \f(CW\*(C`empty\*(C'\fR subrule can only be used if the \f(CW\*(C`preserve\*(C'\fR subrule is
also present.)
.PP
\fIRules that depend on attribute values\fR
.IX Subsection "Rules that depend on attribute values"
.PP
In some circumstances, you might want your dialect's conversion rules
to depend on the value of one or more attributes. The problem is that
a dialect's rules are loaded at compile-time (when the dialect module
is imported via \f(CW\*(C`use\*(C'\fR), but attribute values aren't known until
run-time (when the client code creates a new H::WC object).
.PP
The solution is to define an \f(CW\*(C`_init()\*(C'\fR method, which H::WC will call
on your dialect after attribute values have been assigned. The
\&\f(CW\*(C`_init()\*(C'\fR method takes a single argument, the H::WC object. In it,
you may redefine any rules based on attributes' values; its return
value is discarded. For example, MediaWiki's \f(CW\*(C`_init()\*(C'\fR looks like
this:
.PP
.Vb 5
\&  sub _init {
\&    my $self = shift;
\&    rule( i => { preserve => 1, attributes => \e@common_attrs } ) if $self->preserve_italic;
\&    rule( b => { preserve => 1, attributes => \e@common_attrs } ) if $self->preserve_bold;
\&  }
.Ve
.Sh "Dynamic subrules"
.IX Subsection "Dynamic subrules"
Instead of simple strings, you may use coderefs as values for the
\&\f(CW\*(C`start\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`replace\*(C'\fR, and \f(CW\*(C`line_prefix\*(C'\fR subrules. If you do,
the code will be called when the subrule is applied, and will be
passed three arguments: the current H::WC object, the current
HTML::Element node being operated on, and a reference to the hash
containing the dialect's subrules associated with elements of that
type.
.PP
For example, MoinMoin handles lists like so:
.PP
.Vb 3
\&  rule ul => { line_format => 'multi', block => 1, line_prefix => '  ' };
\&  rule li => { start => \e&_li_start, trim => 'leading' };
\&  rule ol => { alias => 'ul' };
.Ve
.PP
It then defines \f(CW\*(C`_li_start()\*(C'\fR:
.PP
.Vb 7
\&  sub _li_start {
\&    my( $self, $node, $subrules ) = @_;
\&    my $bullet = '';
\&    $bullet = '*'  if $node->parent->tag eq 'ul';
\&    $bullet = '1.' if $node->parent->tag eq 'ol';
\&    return "\en$bullet ";
\&  }
.Ve
.PP
This prefixes every unordered list item with \f(CW"*"\fR and every ordered
list item with \f(CW"1."\fR, which MoinMoin requires. It also puts each
list item on its own line and places a space between the prefix and
the content of the list item.
.Sh "Subrule validation"
.IX Subsection "Subrule validation"
Certain subrule combinations are not allowed. Hopefully it's intuitive
why this is, but in case it's not, I've parenthetically documented
above the disallowed subrule combinations. For example, the \f(CW\*(C`replace\*(C'\fR
and \f(CW\*(C`alias\*(C'\fR subrules cannot be combined with any other subrules, and
\&\f(CW\*(C`attributes\*(C'\fR can only be specified alongside \f(CW\*(C`preserve\*(C'\fR. Invalid
subrule combinations will trigger a fatal error when the H::WC object
is instantiated.
.Sh "Dialect attributes"
.IX Subsection "Dialect attributes"
H::WC's constructor accepts a number of attributes that help determine
how conversion takes place. Dialects can alter these attributes or add
their own by using the \f(CW\*(C`attribute()\*(C'\fR function, which (like \f(CW\*(C`rule()\*(C'\fR)
was imported when H::WC was subclassed (see above). Its syntax is:
.PP
.Vb 1
\&  attribute $attr => \e%spec;
.Ve
.PP
where \f(CW$attr\fR is the name of the attribute and \f(CW%spec\fR is a
Params::Validate specification for the attribute.
.PP
For example, to add a boolean attribute called \f(CW\*(C`camel_case\*(C'\fR which is
disabled by default:
.PP
.Vb 1
\&  attribute camel_case => { default => 0 };
.Ve
.PP
Attributes defined liks this are given accessor and mutator methods
via Perl's \f(CW\*(C`AUTOLOAD\*(C'\fR mechanism, so you can later say:
.PP
.Vb 2
\&  my $ok = $wc->camel_case; # accessor
\&  $wc->camel_case(0); # mutator
.Ve
.PP
You may override the default H::WC attributes using this
mechanism. For example, the PbWiki dialect requires that the
\&\f(CW\*(C`base_uri\*(C'\fR element be defined; however, H::WC doesn't require it by
default (since all attributes are optional by default). Thus the
PbWiki dialect could override this using:
.PP
.Vb 1
\&  attribute base_uri => { optional => 0 };
.Ve
.Sh "Preprocessing"
.IX Subsection "Preprocessing"
The first step H::WC takes in converting \s-1HTML\s0 source to wiki markup is
to parse the \s-1HTML\s0 into a syntax tree using HTML::TreeBuilder. It is
often useful for dialects to preprocess the tree prior to converting
it into wiki markup. Dialects that need to preprocess the tree can
define a \f(CW\*(C`preprocess_node\*(C'\fR method that will be called on each node of
the tree (traversal is done in pre\-order). The method receives two
arguments, the H::WC object, and the current HTML::Element node
being traversed. It may modify the node or decide to ignore it; its
return value is discarded.
.PP
\fIBuilt-in preprocessors\fR
.IX Subsection "Built-in preprocessors"
.PP
Because they are commonly needed, H::WC automatically carries out two
preprocessing steps, regardless of the dialect: 1) relative URIs in
images and links are converted to absolute URIs (based upon the
\&\f(CW\*(C`base_uri\*(C'\fR parameter), and 2) ignorable text (e.g. between a
\&\f(CW\*(C`</td>\*(C'\fR and \f(CW\*(C`<td>\*(C'\fR) is discarded.
.PP
H::WC also provides additional preprocessing steps
that may be explicitly enabled by dialect modules.
.IP "strip_aname" 4
.IX Item "strip_aname"
Removes any anchor elements that do not contain an \f(CW\*(C`href\*(C'\fR attribute.
.IP "caption2para" 4
.IX Item "caption2para"
Removes table captions and reinserts them as paragraphs before the
table.
.PP
Dialects may apply these optional preprocessing steps by calling them
as methods on the dialect object inside \f(CW\*(C`preprocess_node\*(C'\fR. For
example:
.PP
.Vb 5
\&  sub preprocess_node {
\&    my( $self, $node ) = @_;
\&    $self->strip_aname($node);
\&    $self->caption2para($node);
\&  }
.Ve
.Sh "Postprocessing"
.IX Subsection "Postprocessing"
Once the work of converting \s-1HTML\s0 is complete, it is sometimes useful
to postprocess the resulting wiki markup. Postprocessing can be used
to clean up whitespace, fix subtle bugs introduced in the markup
during conversion, etc.
.PP
Dialects that want to postprocess the wiki markup should define a
\&\f(CW\*(C`postprocess_output\*(C'\fR method that will be called just before the
\&\f(CW\*(C`html2wiki\*(C'\fR method returns to the client. The method will be passed
two arguments, the H::WC object and a reference to the wiki
markup. The method may modify the wiki markup that the reference
points to; its return value is discarded.
.PP
For example, to replace a series of line breaks with a pair of
newlines, a dialect might implement this:
.PP
.Vb 4
\&  sub postprocess_output {
\&    my( $self, $outref ) = @_;
\&    $$outref =~ s/<br>\es*<br>/\en\en/gs;
\&  }
.Ve
.PP
(This example assumes that \s-1HTML\s0 line breaks were replaced with
\&\f(CW\*(C`<br>\*(C'\fR in the wiki markup.)
.Sh "Dialect utility methods"
.IX Subsection "Dialect utility methods"
H::WC defines a set of utility methods that dialect modules may find
useful.
.PP
\fIget_elem_contents\fR
.IX Subsection "get_elem_contents"
.PP
.Vb 1
\&  my $wiki = $wc->get_elem_contents( $node );
.Ve
.PP
Converts the contents of \f(CW$node\fR into wiki markup and returns the
resulting wiki markup.
.PP
\fIget_wiki_page\fR
.IX Subsection "get_wiki_page"
.PP
.Vb 1
\&  my $title = $wc->get_wiki_page( $url );
.Ve
.PP
Attempts to extract the title of a wiki page from the given \s-1URL\s0,
returning the title on success, \f(CW\*(C`undef\*(C'\fR on failure. If \f(CW\*(C`wiki_uri\*(C'\fR is
empty, this method always return \f(CW\*(C`undef\*(C'\fR. See
\&\*(L"\s-1ATTRIBUTES\s0\*(R" in HTML::WikiConverter for details on how the \f(CW\*(C`wiki_uri\*(C'\fR
attribute is interpreted.
.PP
\fIis_camel_case\fR
.IX Subsection "is_camel_case"
.PP
.Vb 1
\&  my $ok = $wc->is_camel_case( $str );
.Ve
.PP
Returns true if \f(CW$str\fR is in CamelCase, false
otherwise. CamelCase-ness is determined using the same rules that
Kwiki's formatting module uses.
.PP
\fIget_attr_str\fR
.IX Subsection "get_attr_str"
.PP
.Vb 1
\&  my $attr_str = $wc->get_attr_str( $node, @attrs );
.Ve
.PP
Returns a string containing the specified attributes in the given
node. The returned string is suitable for insertion into an \s-1HTML\s0 tag.
For example, if \f(CW$node\fR contains the \s-1HTML\s0
.PP
.Vb 1
\&  <style id="ht" class="head" onclick="editPage()">Header</span>
.Ve
.PP
and \f(CW@attrs\fR contains \f(CW"id"\fR and \f(CW"class"\fR, then \f(CW\*(C`get_attr_str()\*(C'\fR
will return \f(CW'id="ht" class="head"'\fR.
.PP
\fI_attr\fR
.IX Subsection "_attr"
.PP
.Vb 1
\&  my $value = $wc->_attr( $name );
.Ve
.PP
Returns the value of the named attribute. This is rarely needed since
you can access attribute values by treating the attribute name as a
method (i.e., \f(CW\*(C`$wc\->$name\*(C'\fR). This low-level method of accessing
attributes is provided for when you need to override an attribute's
accessor/mutator method, as in:
.PP
.Vb 1
\&  attribute my_attr => { default => 1 };
.Ve
.PP
.Vb 5
\&  sub my_attr {
\&    my( $wc, $name, $new_value ) = @_;
\&    # do something special
\&    return $wc->_attr( $name => $new_value );
\&  }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David J. Iberri <diberri@cpan.org>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006 David J. Iberri, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
